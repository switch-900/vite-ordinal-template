===== src/App.jsx =====
import {Canvas, useThree} from "@react-three/fiber";
import {Suspense, useState} from "react";
import {CameraManager} from "./components/core/CameraManager.jsx";
import {useScene} from "./state/sceneStore.jsx";
import {useKeyboardShortcuts} from "./hooks/useKeyboardShortcuts.js";
import {EnvironmentLighting} from "./components/core/EnvironmentLighting.jsx";
import {GridFloor} from "./components/GridFloor.jsx";
// Tool components
import {SketchCanvas} from "./components/tools/SketchCanvas.jsx";
import {SketchToolbar} from "./components/tools/SketchToolbar.jsx";
import {SceneRenderer} from "./components/core/SceneRenderer.jsx";
import {Leva} from "leva";
import {BoxelInfo} from "./components/ui/BoxelInfo.jsx";
import {ViewerApp} from "./ViewerApp.jsx";
import {MainLayout} from "./components/layout/MainLayout.jsx";
import {ViewportToolbar} from "./components/layout/ViewportToolbar.jsx";
export function App() {
    const [appMode, setAppMode] = useState('builder'); // 'builder' or 'viewer'
    const [viewerSceneData, setViewerSceneData] = useState(null);
    // Enable keyboard shortcuts
    useKeyboardShortcuts();
    const Scene = () => {
      const { viewMode } = useScene();
        return (
            <>
                {viewMode === '2d' && <SketchToolbar />}
                {viewMode === '3d' && <ViewportToolbar />}
                <Canvas dpr={1}>
                    <CameraManager />
                    <color attach="background" args={[0.02, 0.02, 0.022]} />
                    <Suspense>
                        {viewMode === '2d' ? (
                          <SketchCanvas />
                        ) : (
                          <>
                            <EnvironmentLighting />
                            <SceneRenderer />
                            <GridFloor />
                          </>
                        )}
                    </Suspense>
                </Canvas>
            </>
        )
    }
    if (appMode === 'viewer') {
        return <ViewerApp
            sceneData={viewerSceneData}
            onBackToBuilder={() => setAppMode('builder')}
        />;
    }
        return (
        <MainLayout onLoadInViewer={(data) => {
            setViewerSceneData(data);
            setAppMode('viewer');
        }}>
            <Scene/>
            <Leva hidden={window.innerWidth < 300} />
            <BoxelInfo />
        </MainLayout>
    )
}
export default App

===== src/ViewerApp.jsx =====
// filepath: src/ViewerApp.jsx
import React, { Suspense } from 'react';
import { Canvas } from '@react-three/fiber';
import { CameraControls, Environment } from '@react-three/drei';
// Simple viewer that can load and display exported scenes
export const ViewerApp = ({ sceneData, onBackToBuilder }) => {
  const renderScene = () => {
    if (!sceneData) return null;
    // Parse JSON scene data if provided
    if (typeof sceneData === 'string') {
      try {
        const objects = JSON.parse(sceneData);
        return objects.map((obj, index) => (
          <mesh
            key={index}
            position={obj.position}
            rotation={obj.rotation}
            scale={obj.scale}
          >
            {getGeometry(obj.geometry, obj.args)}
            {getMaterial(obj.material)}
          </mesh>
        ));
      } catch (e) {
        console.error('Failed to parse scene data:', e);
        return null;
      }
    }
    return null;
  };
  const getGeometry = (geometry, args) => {
    switch (geometry) {
      case 'box':
        return <boxGeometry args={args} />;
      case 'sphere':
        return <sphereGeometry args={args} />;
      case 'cylinder':
        return <cylinderGeometry args={args} />;
      case 'plane':
        return <planeGeometry args={args} />;
      case 'cone':
        return <coneGeometry args={args} />;
      default:
        return <boxGeometry args={[1, 1, 1]} />;
    }
  };
  const getMaterial = (material) => {
    return (
      <meshStandardMaterial
        color={material.color}
        metalness={material.metalness}
        roughness={material.roughness}
      />
    );
  };
  return (
    <div className="w-full h-full">
      <div className="absolute top-2 left-2 z-10 bg-gray-900 bg-opacity-80 text-white p-2 rounded">
        <h3 className="text-sm font-bold">3D Viewer</h3>
        <p className="text-xs text-gray-300">Orbit • Pan • Zoom</p>
        {onBackToBuilder && (
          <button
            className="mt-2 px-2 py-1 bg-orange-600 text-white rounded text-xs hover:bg-orange-700"
            onClick={onBackToBuilder}
          >
            ← Back to Builder
          </button>
        )}
      </div>
      <Canvas
        camera={{ position: [5, 5, 5], fov: 45 }}
        dpr={1}
      >
        <color attach="background" args={[0.1, 0.1, 0.12]} />
        <Suspense fallback={null}>
          <Environment preset="city" environmentIntensity={0.3} />
          <ambientLight intensity={0.5} />
          <directionalLight position={[10, 10, 5]} intensity={1} />
          {renderScene()}
          <CameraControls makeDefault />
        </Suspense>
      </Canvas>
    </div>
  );
};

===== src/components/GridFloor.jsx =====
import {Grid} from "@react-three/drei";
import {useEffect, useRef} from "react";
export const GridFloor = () => {
    const ref = useRef()
    useEffect(() => {
        window.gridFloor = ref.current
    }, [])
    return (
        <Grid {...{
            gridSize: [1, 1],
            cellSize: 0.1,
            cellThickness: 1,
            cellColor: '#6f6f6f',
            sectionSize: 1,
            sectionThickness: 1.5,
            sectionColor: '#ff6600',
            fadeDistance: 200,
            fadeStrength: 50,
            followCamera: true,
            infiniteGrid: true,
        }}
        position={[0, -0.5, 0.0]}
        ref={ref}
        // Ensure grid doesn't interfere with drag operations
        raycast={() => null}
        />
    )
}

===== src/components/TestBoxel.jsx =====
import {boxelGeometry} from "boxels-shader";
import {useControls} from "leva";
import CustomShaderMaterial from 'three-custom-shader-material'
import * as THREE from "three";
export const TestBoxel = () => {
    const [{scale, angle}] = useControls('edit boxel', () => {
        return {
            scale: {
                value: 1,
                min: 0.1,
                max: 2,
                step: 0.01,
            },
            angle: {
                value: 0.1,
                min: 0.01,
                max: 0.99,
                step: 0.01
            }
        }
    }, {color: '#ff9900'})
    return (
        <mesh geometry={boxelGeometry} scale={scale}>
            <CustomShaderMaterial
            baseMaterial={THREE.MeshStandardMaterial}
            flatShading={true}
            transparent={true}
            uniforms={{time: {value: 0}}}
                key={angle}
            vertexShader={`
            // adjust shape here when instancing
            attribute float angle;
            varying vec3 vPos;
            varying vec3 vNormal;
            void main() {
            csm_Position += normal * ${angle-0.2 + 0.01} * 0.5; // test mode
            vPos = csm_Position;
            vNormal = normal;
        }
            `}
            fragmentShader={`
            varying vec3 vPos;
            varying vec3 vNormal;
            uniform float time;
            void main() {
                csm_DiffuseColor = vec4(1.8, 0.5, 0., 1.);
            }
            `} />
        </mesh>
    )
}

===== src/components/core/CameraManager.jsx =====
import {CameraControls} from "@react-three/drei";
import {useEffect, useRef} from "react";
import {useFrame} from "@react-three/fiber";
import {useScene} from "../../state/sceneStore.jsx";
export const CameraManager = () => {
    const ref = useRef()
    const { transformMode, selectedIds } = useScene();
    useEffect(() => {
        window.cam = ref.current
        ref.current.moveTo(-0.0, 0.0, 0.0, true)
        ref.current.rotateTo(0.3, 1.2, 0, true)
        ref.current.dollyTo(9, true)
    }, [])
    useFrame(() => {
        // TEMPORARILY DISABLED - Testing if auto-rotation causes camera reset
        // Only rotate when not actively transforming objects
        // if (!transformMode || selectedIds.length === 0) {
        //     ref.current.rotate(0.002, 0, true)
        // }
    })
    return (
        <CameraControls makeDefault ref={ref} />
    )
}

===== src/components/core/EnvironmentLighting.jsx =====
import {Environment} from "@react-three/drei";
export const EnvironmentLighting = () => {
    return (
        <Environment environmentIntensity={0.75}
            files={'/content/8c4ea8f9fafef081345ba8a72c08efed2373d0ba33ac92aca5f043071fc42909i0?.hdr'}
        />
    )
}

===== src/components/core/SceneRenderer.jsx =====
// filepath: src/components/core/SceneRenderer.jsx
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useThree, useFrame } from '@react-three/fiber';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import { GizmoControls } from '../ui/GizmoControls';
import { SimpleTransformControls } from '../ui/SimpleTransformControls';
import { Geometry, Base, Addition, Subtraction, Intersection } from '@react-three/csg';
import { boxelGeometry } from "boxels-shader";
import CustomShaderMaterial from 'three-custom-shader-material';
import * as THREE from "three";
export const SceneRenderer = () => {
  const { objects, selectedObjectId, selectedIds, layers, groups = [], transformMode } = useScene();
  const { selectObjects, toggleObjectSelection, clearSelection } = useSceneActions();
  const meshRefs = useRef({});
  const [time, setTime] = useState(0);
  const isGizmoDragging = useRef(false);
  const isInteracting = useRef(false); // Track if user is interacting with the scene
  // Animation time for shaders
  useFrame((state, delta) => {
    setTime(prevTime => prevTime + delta);
  });
  // Filter objects based on layer visibility and group visibility
  const visibleObjects = objects.filter(obj => {
    // Check layer visibility
    const layer = layers.find(l => l.id === obj.layerId);
    const layerVisible = layer ? layer.visible : true;
    // Check group visibility if object belongs to a group
    if (obj.groupId) {
      const group = groups.find(g => g.id === obj.groupId);
      const groupVisible = group ? group.visible : true;
      return layerVisible && groupVisible;
    }
    return layerVisible;
  });
  const handleClick = (objectId, event) => {
    // Stop propagation to prevent canvas click handler from triggering
    event.stopPropagation();
    // Set interaction flag briefly
    isInteracting.current = true;
    setTimeout(() => {
      isInteracting.current = false;
    }, 100);
    // Don't change selection during gizmo operations
    if (isGizmoDragging.current) {
      return;
    }
    // Handle selection based on modifier keys
    if (event.ctrlKey || event.metaKey) {
      toggleObjectSelection(objectId);
    } else {
      selectObjects([objectId]);
    }
  };
  const handleCanvasClick = (event) => {
    // Don't clear selection if we're in the middle of a gizmo operation
    if (isGizmoDragging.current || isInteracting.current) {
      return;
    }
    // Don't clear selection immediately if transform mode is active
    // Give users time to interact with transform controls
    if (transformMode && selectedIds.length > 0) {
      return;
    }
    clearSelection();
  };
  // Get mesh reference for TransformGizmo
  const getSelectedMesh = () => {
    return selectedObjectId ? meshRefs.current[selectedObjectId] : null;
  };
  // Apply custom angle modification to a geometry if needed
  const applyAngleModification = (geometry, angle = 0.1) => {
    if (!geometry || angle === undefined) return geometry;
    // Clone the geometry to avoid modifying the original
    const modifiedGeometry = geometry.clone();
    // Apply angle modification to each vertex
    const vertices = modifiedGeometry.attributes.position;
    const normals = modifiedGeometry.attributes.normal;
    for (let i = 0; i < vertices.count; i++) {
      const nx = normals.getX(i);
      const ny = normals.getY(i);
      const nz = normals.getZ(i);
      // Move vertex along its normal direction based on angle value
      vertices.setXYZ(
        i,
        vertices.getX(i) + nx * angle * 0.5,
        vertices.getY(i) + ny * angle * 0.5,
        vertices.getZ(i) + nz * angle * 0.5
      );
    }
    vertices.needsUpdate = true;
    return modifiedGeometry;
  };
  const getGeometry = (geometry, args, angle) => {
    // For boxel, we use the pre-built geometry with custom shader
    if (geometry === 'boxel') {
      return boxelGeometry;
    }
    // For other geometries
    let threeGeometry;
    switch (geometry) {
      case 'box':
        return <boxGeometry args={args} />;
      case 'sphere':
        return <sphereGeometry args={args} />;
      case 'cylinder':
        return <cylinderGeometry args={args} />;
      case 'plane':
        return <planeGeometry args={args} />;
      case 'cone':
        return <coneGeometry args={args} />;
      default:
        return <boxGeometry args={[1, 1, 1]} />;
    }
  };
  const getBooleanGeometry = (booleanObj) => {
    // Get all source objects, even if they're currently hidden
    const sourceObjs = objects.filter(obj => booleanObj.sourceObjects.includes(obj.id));
    if (sourceObjs.length < 2) return null;
    const [firstObj, secondObj, ...restObjs] = sourceObjs;
    // Calculate offset to position the geometry relative to the boolean object's position
    const calculateOffset = (obj) => {
      return [
        obj.position[0] - booleanObj.position[0],
        obj.position[1] - booleanObj.position[1],
        obj.position[2] - booleanObj.position[2]
      ];
    };
    const getGeometryMesh = (obj) => (
      <mesh position={calculateOffset(obj)} rotation={obj.rotation} scale={obj.scale}>
        {getGeometry(obj.geometry, obj.geometryArgs)}
      </mesh>
    );
    // Render boolean operations with proper CSG geometry
    return (
      <Geometry>
        <Base>
          {getGeometryMesh(firstObj)}
        </Base>
        {booleanObj.operation === 'union' && (
          <Addition>
            {getGeometryMesh(secondObj)}
            {restObjs.map(obj => (
              <Addition key={obj.id}>
                {getGeometryMesh(obj)}
              </Addition>
            ))}
          </Addition>
        )}
        {booleanObj.operation === 'subtract' && (
          <Subtraction>
            {getGeometryMesh(secondObj)}
            {restObjs.map(obj => (
              <Subtraction key={obj.id}>
                {getGeometryMesh(obj)}
              </Subtraction>
            ))}
          </Subtraction>
        )}
        {booleanObj.operation === 'intersect' && (
          <Intersection>
            {getGeometryMesh(secondObj)}
            {restObjs.map(obj => (
              <Intersection key={obj.id}>
                {getGeometryMesh(obj)}
              </Intersection>
            ))}
          </Intersection>
        )}
      </Geometry>
    );
  };
  const getMaterial = (material, isSelected, isBoxel = false, obj = null) => {
    // Get angle from object or default to 0.1
    const angle = obj?.angle || 0.1;
    // Use simple MeshStandardMaterial for most cases, CustomShaderMaterial only for boxel or when angle is used
    if (!isBoxel && angle === 0.1) {
      return (
        <meshStandardMaterial
          transparent={isSelected || (material?.opacity !== undefined && material?.opacity < 1.0)}
          opacity={isSelected ? 0.8 : (material?.opacity || 1.0)}
          color={isSelected ? '#ffaa00' : material?.color || '#808080'}
          metalness={material?.metalness || 0.1}
          roughness={material?.roughness || 0.8}
          emissive={material?.emissive || '#000000'}
          emissiveIntensity={material?.emissiveIntensity || 0.0}
        />
      );
    }
    // Use CustomShaderMaterial for boxel geometry or when angle modification is needed
    return (
      <CustomShaderMaterial
        baseMaterial={THREE.MeshStandardMaterial}
        flatShading={true}
        transparent={isSelected || (material?.opacity !== undefined && material?.opacity < 1.0)}
        opacity={isSelected ? 0.8 : (material?.opacity || 1.0)}
        color={isSelected ? '#ffaa00' : material?.color || '#808080'}
        metalness={material?.metalness || 0.1}
        roughness={material?.roughness || 0.8}
        emissive={material?.emissive || '#000000'}
        emissiveIntensity={material?.emissiveIntensity || 0.0}
        uniforms={{
          time: {value: time},
          angle: {value: angle} // Pass angle as uniform instead of forcing re-render
        }}
        vertexShader={`
          attribute float angle;
          varying vec3 vPos;
          varying vec3 vNormal;
          uniform float time;
          uniform float angle;
          void main() {
            // Use uniform angle instead of template literal
            csm_Position += normal * (angle - 0.2 + 0.01) * 0.5;
            vPos = csm_Position;
            vNormal = normal;
          }
        `}
        fragmentShader={`
          varying vec3 vPos;
          varying vec3 vNormal;
          uniform float time;
          void main() {
            ${isSelected ? 'float colorPulse = sin(time) * 0.05 + 0.95; csm_DiffuseColor.rgb *= colorPulse;' : ''}
          }
        `}
      />
    );
  };
  return (
    <>
      {/* Background plane for click handling */}
      {/* Background plane - completely disabled during transform operations */}
      {!transformMode && (
        <mesh
          position={[0, -0.01, 0]}
          rotation={[-Math.PI / 2, 0, 0]}
          onClick={handleCanvasClick}
          visible={false}
        >
          <planeGeometry args={[1000, 1000]} />
          <meshBasicMaterial transparent opacity={0} />
        </mesh>
      )}
      <group>
        {visibleObjects.map((obj) => {
          if (!obj.visible) return null;
          const isSelected = selectedIds.includes(obj.id);
          // Handle boolean objects differently
          if (obj.type === 'boolean') {
            return (
              <mesh
                key={obj.id}
                ref={(ref) => {
                  if (ref) {
                    meshRefs.current[obj.id] = ref;
                    ref.name = `mesh-${obj.id}`;
                    ref.userData = { objectId: obj.id, objectType: 'boolean' };
                  }
                }}
                position={obj.position}
                rotation={obj.rotation}
                scale={obj.scale}
                onClick={(e) => handleClick(obj.id, e)}
              >
                {getBooleanGeometry(obj)}
                {getMaterial(obj.material, isSelected, false, obj)}
              </mesh>
            );
          }
          // Handle regular objects
          return (
            <mesh
              key={obj.id}
              ref={(ref) => {
                if (ref) {
                  meshRefs.current[obj.id] = ref;
                  ref.name = `mesh-${obj.id}`;
                  // Store important properties in userData for efficient access
                  ref.userData = {
                    objectId: obj.id,
                    objectType: obj.geometry,
                    angle: obj.angle || 0.1 // Default angle value for shape modification
                  };
                }
              }}
              position={obj.position}
              rotation={obj.rotation}
              scale={obj.scale}
              onClick={(e) => handleClick(obj.id, e)}
              geometry={obj.geometry === 'boxel' ? boxelGeometry : undefined}
            >
              {obj.geometry !== 'boxel' && getGeometry(obj.geometry, obj.geometryArgs, obj.angle)}
              {getMaterial(obj.material, isSelected, obj.geometry === 'boxel', obj)}
            </mesh>
          );
        })}
      </group>
      {/* Render transform controls LAST to ensure event priority */}
      <GizmoControls
        selectedMesh={getSelectedMesh()}
        onDraggingChanged={(isDragging) => isGizmoDragging.current = isDragging}
      />
    </>
  );
};

===== src/components/layout/LeftSidebar.jsx =====
// Left sidebar with organized tool panels
import React, { useState } from 'react';
import { useScene } from '../../state/sceneStore.jsx';
import { PrimitiveTools } from '../tools/PrimitiveTools.jsx';
import { AdvancedTools } from '../tools/AdvancedTools.jsx';
import { MaterialEditor } from '../ui/MaterialEditor.jsx';
import { ObjectManager } from '../ui/ObjectManager.jsx';
import { LayerManager } from '../ui/LayerManager.jsx';
import { SettingsPanel } from '../ui/SettingsPanel.jsx';
import { ExportPanel } from '../ui/ExportPanel_sidebar.jsx';
export const LeftSidebar = ({ onLoadInViewer }) => {
  const { viewMode } = useScene();
  const [activePanel, setActivePanel] = useState('primitives');
  const [isCollapsed, setIsCollapsed] = useState(false);
  const panels = [
    { id: 'primitives', name: 'Primitives', icon: '⬛', component: PrimitiveTools },
    { id: 'advanced', name: 'Advanced', icon: '🔧', component: AdvancedTools },
    { id: 'materials', name: 'Materials', icon: '🎨', component: MaterialEditor },
    { id: 'objects', name: 'Objects', icon: '📦', component: ObjectManager },
    { id: 'layers', name: 'Layers', icon: '📚', component: LayerManager },
    { id: 'export', name: 'Export', icon: '📤', component: ExportPanel },
    { id: 'settings', name: 'Settings', icon: '⚙️', component: SettingsPanel },
  ];
  // Filter panels based on view mode
  const availablePanels = panels.filter(panel => {
    if (viewMode === '2d') {
      return ['objects', 'layers', 'export', 'settings'].includes(panel.id);
    }
    return true; // Show all panels in 3D mode
  });
  const ActiveComponent = availablePanels.find(p => p.id === activePanel)?.component;
  return (
    <div className={`bg-gray-900 border-r border-gray-700 flex flex-col transition-all duration-300 ${
      isCollapsed ? 'w-12' : 'w-80'
    }`}>
      {/* Sidebar Header */}
      <div className="flex items-center justify-between p-3 border-b border-gray-700">
        {!isCollapsed && (
          <h2 className="text-white font-semibold">Tools</h2>
        )}
        <button
          onClick={() => setIsCollapsed(!isCollapsed)}
          className="p-1 text-gray-400 hover:text-white rounded"
        >
          {isCollapsed ? '▶' : '◀'}
        </button>
      </div>
      {/* Panel Tabs */}
      <div className={`flex ${isCollapsed ? 'flex-col' : 'flex-wrap'} ${
        isCollapsed ? 'items-center' : 'border-b border-gray-700'
      }`}>
        {availablePanels.map((panel) => (
          <button
            key={panel.id}
            onClick={() => setActivePanel(panel.id)}
            className={`${
              isCollapsed
                ? 'w-10 h-10 m-1'
                : 'flex-1 min-w-0 px-3 py-2'
            } flex items-center justify-center text-sm transition-colors ${
              activePanel === panel.id
                ? 'bg-orange-600 text-white'
                : 'text-gray-400 hover:text-white hover:bg-gray-800'
            }`}
            title={panel.name}
          >
            <span className="text-lg">{panel.icon}</span>
            {!isCollapsed && (
              <span className="ml-2 truncate">{panel.name}</span>
            )}
          </button>
        ))}
      </div>
      {/* Panel Content */}
      {!isCollapsed && (
        <div className="flex-1 overflow-y-auto">
          {ActiveComponent && (
            <div className="p-4">
              <ActiveComponent onLoadInViewer={onLoadInViewer} />
            </div>
          )}
        </div>
      )}
    </div>
  );
};

===== src/components/layout/MainLayout.jsx =====
// Main layout wrapper for the SketchUp-style interface
import React from 'react';
import { TopToolbar } from './TopToolbar.jsx';
import { LeftSidebar } from './LeftSidebar.jsx';
import { StatusBar } from './StatusBar.jsx';
import { TransformIndicator } from '../ui/TransformIndicator.jsx';
export const MainLayout = ({ children, onLoadInViewer }) => {
  return (
    <div className="w-full h-full flex flex-col bg-gray-800 overflow-hidden">
      {/* Top Toolbar */}
      <TopToolbar />
      {/* Main Content Area */}
      <div className="flex-1 flex overflow-hidden">
        {/* Left Sidebar */}
        <LeftSidebar onLoadInViewer={onLoadInViewer} />
        {/* 3D Viewport */}
        <div className="flex-1 relative bg-gray-900">
          {children}
          <TransformIndicator />
        </div>
      </div>
      {/* Status Bar */}
      <StatusBar />
    </div>
  );
};

===== src/components/layout/StatusBar.jsx =====
// Status bar at the bottom showing current state and statistics
import React from 'react';
import { useScene } from '../../state/sceneStore.jsx';
export const StatusBar = () => {
  const { objects, selectedIds, viewMode, currentTool, snapToGrid, gridSize, transformMode } = useScene();
  const selectedCount = selectedIds.length;
  const totalObjects = objects.length;
  const visibleObjects = objects.filter(obj => obj.visible).length;
  const getStatusMessage = () => {
    if (selectedCount === 0) {
      return "Select objects to modify them • Click primitives in sidebar to add objects";
    }
    if (viewMode === '3d' && selectedCount > 0) {
      const modeKey = transformMode === 'translate' ? 'G' : transformMode === 'rotate' ? 'R' : transformMode === 'scale' ? 'S' : '';
      return `Transform mode: ${transformMode} • Press ${modeKey} to switch • Drag gizmo to transform`;
    }
    return "Use transform tools or edit properties in the sidebar";
  };
  return (
    <div className="bg-gray-900 border-t border-gray-700 px-4 py-2 flex items-center justify-between text-sm text-gray-400">
      {/* Left side - Object counts and selection info */}
      <div className="flex items-center space-x-4">
        <span>Objects: {visibleObjects}/{totalObjects}</span>
        {selectedCount > 0 && (
          <span className="text-orange-400">Selected: {selectedCount}</span>
        )}
        <span>Mode: {viewMode.toUpperCase()}</span>
        {viewMode === '2d' && (
          <span>Tool: {currentTool}</span>
        )}
      </div>
      {/* Center - Current action or tip */}
      <div className="text-center flex-1">
        <span className="text-blue-300">{getStatusMessage()}</span>
      </div>
      {/* Right side - Settings and coordinates */}
      <div className="flex items-center space-x-4">
        <div className="flex items-center space-x-2">
          <span className={`w-2 h-2 rounded-full ${snapToGrid ? 'bg-green-500' : 'bg-gray-600'}`}></span>
          <span>Grid: {gridSize}m</span>
        </div>
        <span>Coords: [0, 0, 0]</span>
      </div>
    </div>
  );
};

===== src/components/layout/TopToolbar.jsx =====
// Top toolbar component with main tool categories
import React from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
export const TopToolbar = () => {
  const { viewMode, setSceneState, selectedIds } = useScene();
  const { clearSelection } = useSceneActions();
  const handleModifyAction = (action) => {
    switch(action) {
      case 'Move':
        setSceneState({ transformMode: 'translate' });
        break;
      case 'Rotate':
        setSceneState({ transformMode: 'rotate' });
        break;
      case 'Scale':
        setSceneState({ transformMode: 'scale' });
        break;
      default:
        break;
    }
  };
  const toolCategories = [
    { name: 'File', icon: '📁', items: ['New', 'Open', 'Save', 'Export'] },
    { name: 'Edit', icon: '✏️', items: ['Undo', 'Redo', 'Copy', 'Paste'] },
    { name: 'View', icon: '👁️', items: ['2D', '3D', 'Grid', 'Wireframe'] },
    { name: 'Draw', icon: '✏️', items: ['Line', 'Rectangle', 'Circle', 'Polygon'] },
    { name: 'Modify', icon: '🔧', items: ['Move', 'Rotate', 'Scale', 'Mirror'], hasAction: true },
    { name: 'Tools', icon: '🛠️', items: ['Measure', 'Text', 'Dimension'] },
  ];
  return (
    <div className="w-full bg-gray-800 border-b border-gray-700 shadow-lg">
      {/* Main Menu Bar */}
      <div className="flex items-center justify-between px-4 py-2 bg-gray-900">
        <div className="flex items-center space-x-1">
          <div className="text-orange-500 font-bold text-lg">🟧 Bitmap Nexus Builder 🟧</div>
        </div>
        {/* View Mode Toggle */}
        <div className="flex items-center space-x-2">
          <button
            onClick={() => setSceneState({ viewMode: '2d' })}
            className={`px-3 py-1 rounded text-sm ${
              viewMode === '2d'
                ? 'bg-orange-600 text-white'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }`}
          >
            2D Sketch
          </button>
          <button
            onClick={() => setSceneState({ viewMode: '3d' })}
            className={`px-3 py-1 rounded text-sm ${
              viewMode === '3d'
                ? 'bg-orange-600 text-white'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }`}
          >
            3D Model
          </button>
        </div>
      </div>
      {/* Tool Categories */}
      <div className="flex items-center px-2 py-1 bg-gray-800 overflow-x-auto">
        {toolCategories.map((category) => (
          <div key={category.name} className="relative group">
            <button className="flex items-center space-x-1 px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded">
              <span>{category.icon}</span>
              <span>{category.name}</span>
            </button>
            {/* Dropdown menu */}
            <div className="absolute top-full left-0 mt-1 w-40 bg-gray-900 border border-gray-700 rounded shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
              {category.items.map((item) => (
                <button
                  key={item}
                  onClick={() => category.hasAction && handleModifyAction(item)}
                  className={`w-full text-left px-3 py-2 text-sm transition-colors first:rounded-t last:rounded-b ${
                    category.hasAction
                      ? 'text-gray-300 hover:bg-gray-700'
                      : 'text-gray-500 cursor-not-allowed'
                  }`}
                  disabled={!category.hasAction}
                >
                  {item}
                </button>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

===== src/components/layout/ViewportToolbar.jsx =====
// Floating toolbar for quick access tools in the viewport
import React from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
export const ViewportToolbar = () => {
  const { selectedIds, transformMode, setSceneState } = useScene();
  const { clearSelection } = useSceneActions();
  const transformModes = [
    { id: 'translate', icon: '↔', name: 'Move' },
    { id: 'rotate', icon: '🔄', name: 'Rotate' },
    { id: 'scale', icon: '↗', name: 'Scale' },
  ];
  return (
    <div className="absolute top-4 left-1/2 transform -translate-x-1/2 z-10 flex items-center space-x-2 bg-gray-900 bg-opacity-90 p-2 rounded-lg shadow-lg">
      {/* Selection Info */}
      <div className="text-white text-sm px-2">
        {selectedIds.length === 0 ? (
          <span className="text-gray-400">No selection</span>
        ) : (
          <span>{selectedIds.length} selected</span>
        )}
      </div>
      {/* Separator */}
      {selectedIds.length > 0 && (
        <div className="w-px h-6 bg-gray-600"></div>
      )}
      {/* Transform Tools */}
      {selectedIds.length > 0 && (
        <>
          <div className="flex space-x-1">
            {transformModes.map((mode) => (
              <button
                key={mode.id}
                onClick={() => setSceneState({ transformMode: mode.id })}
                className={`px-4 py-2 rounded text-sm transition-colors ${
                  transformMode === mode.id
                    ? 'bg-orange-600 text-white shadow-lg font-bold'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
                title={`${mode.name} (${mode.id === 'translate' ? 'G' : mode.id === 'rotate' ? 'R' : 'S'})`}
              >
                <span className="mr-2 text-lg">{mode.icon}</span>
                {mode.name}
              </button>
            ))}
          </div>
          <div className="w-px h-6 bg-gray-600"></div>
          {/* Clear Selection */}
          <button
            onClick={(e) => {
              // Simple clear selection - no transform mode reset
              clearSelection();
            }}
            className="px-3 py-1 rounded text-sm bg-gray-700 text-gray-300 hover:bg-red-600 hover:text-white transition-colors"
            title="Clear Selection (Esc)"
          >
            ✕ Clear
          </button>
        </>
      )}
      {/* Transform Mode Indicator */}
      {selectedIds.length > 0 && (
        <>
          <div className="w-px h-6 bg-gray-600"></div>
          <div className="text-xs text-gray-400 px-2">
            Mode: <span className="text-orange-400 font-medium">{transformMode || 'translate'}</span>
          </div>
        </>
      )}
    </div>
  );
};

===== src/components/tools/AdvancedTools.jsx =====
// filepath: src/components/tools/AdvancedTools.jsx
import React from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import * as THREE from 'three';
const advancedOps = [
  { name: 'Extrude', icon: '⬆️', type: 'extrude' },
  { name: 'Revolve', icon: '🔄', type: 'revolve' },
  { name: 'Union', icon: '➕', type: 'union' },
  { name: 'Subtract', icon: '➖', type: 'subtract' },
  { name: 'Intersect', icon: '✂️', type: 'intersect' },
  { name: 'Mirror', icon: '🪞', type: 'mirror' },
];
export const AdvancedTools = () => {
  const { objects, selectedIds } = useScene();
  const { addObject, updateObject, selectObjects } = useSceneActions();
  const createBooleanOperation = async (operation) => {
    const selectedObjects = objects.filter(obj => selectedIds.includes(obj.id));
    if (selectedObjects.length < 2) {
      console.warn(`Need at least 2 objects for ${operation}, got ${selectedObjects.length}`);
      return;
    }
    console.log(`🔧 Creating ${operation} operation with ${selectedObjects.length} objects`);
    // ✅ Calculate center position more accurately
    const positions = selectedObjects.map(obj => new THREE.Vector3(...obj.position));
    const center = positions.reduce((acc, pos) => acc.add(pos), new THREE.Vector3()).divideScalar(positions.length);
    // ✅ Create boolean object with better naming and properties
    const newObject = {
      id: `boolean_${operation}_${Date.now()}`,
      name: `${operation.charAt(0).toUpperCase() + operation.slice(1)}_${selectedObjects.length}obj`,
      type: 'boolean',
      operation,
      sourceObjects: [...selectedIds], // ✅ Use spread to avoid reference issues
      position: [
        Math.round(center.x * 100) / 100,
        Math.round(center.y * 100) / 100,
        Math.round(center.z * 100) / 100
      ],
      rotation: [0, 0, 0],
      scale: [1, 1, 1],
      material: {
        color: operation === 'union' ? '#4a90e2' : operation === 'subtract' ? '#e74c3c' : '#f39c12',
        metalness: 0.1,
        roughness: 0.8,
        opacity: 0.9 // ✅ Slightly transparent to show it's a boolean result
      },
      visible: true,
      locked: false,
      // ✅ Store original object data for undo operations
      originalObjects: selectedObjects.map(obj => ({...obj}))
    };
    try {
      // ✅ Add object first, then hide sources to prevent selection issues
      addObject(newObject);
      // ✅ Hide source objects but keep them for boolean operations
      selectedIds.forEach(id => {
        updateObject(id, {
          visible: false,
          hiddenBy: newObject.id // ✅ Track what hid this object
        });
      });
      // ✅ Select the new boolean object
      selectObjects([newObject.id]);
      console.log(`✅ Successfully created ${operation} operation:`, newObject.id);
    } catch (error) {
      console.error(`❌ Failed to create ${operation} operation:`, error);
    }
  };
  const performOperation = async (type) => {
    const selectedObjects = objects.filter(obj => selectedIds.includes(obj.id));
    console.log(`🛠️ Performing ${type} operation on ${selectedObjects.length} objects`);
    try {
      switch (type) {
        case 'extrude':
          if (selectedObjects.length === 1) {
            await performExtrude(selectedObjects[0]);
          } else {
            console.warn('Extrude requires exactly 1 object');
          }
          break;
        case 'revolve':
          if (selectedObjects.length === 1) {
            await performRevolve(selectedObjects[0]);
          } else {
            console.warn('Revolve requires exactly 1 object');
          }
          break;
        case 'union':
          if (selectedObjects.length >= 2) {
            await createBooleanOperation('union');
          } else {
            console.warn('Union requires at least 2 objects');
          }
          break;
        case 'subtract':
          if (selectedObjects.length >= 2) {
            await createBooleanOperation('subtract');
          } else {
            console.warn('Subtract requires at least 2 objects');
          }
          break;
        case 'intersect':
          if (selectedObjects.length >= 2) {
            await createBooleanOperation('intersect');
          } else {
            console.warn('Intersect requires at least 2 objects');
          }
          break;
        case 'mirror':
          if (selectedObjects.length >= 1) {
            await performMirror(selectedObjects);
          }
          break;
        default:
          console.warn('Unknown operation:', type);
      }
    } catch (error) {
      console.error(`❌ Operation ${type} failed:`, error);
    }
  };
  // ✅ Improved extrude operation
  const performExtrude = async (obj) => {
    const extrudedObj = {
      id: `extruded_${Date.now()}`,
      name: `${obj.name}_extruded`,
      type: 'mesh',
      geometry: obj.geometry === 'plane' ? 'box' : obj.geometry, // ✅ Convert plane to box for extrude
      geometryArgs: obj.geometryArgs ?
        [obj.geometryArgs[0] || 1, obj.geometryArgs[1] || 1, (obj.geometryArgs[1] || 1) * 2] :
        [1, 1, 2],
      material: { ...obj.material, color: '#2ecc71' }, // ✅ Green for extruded objects
      position: [...obj.position],
      rotation: [...obj.rotation],
      scale: [...obj.scale],
      visible: true,
      locked: false,
      sourceObject: obj.id // ✅ Track source for undo
    };
    addObject(extrudedObj);
    selectObjects([extrudedObj.id]);
    console.log('✅ Extrude operation completed:', extrudedObj.id);
  };
  // ✅ Improved revolve operation
  const performRevolve = async (obj) => {
    const revolvedObj = {
      id: `revolved_${Date.now()}`,
      name: `${obj.name}_revolved`,
      type: 'mesh',
      geometry: 'cylinder', // ✅ Always use cylinder for revolve
      geometryArgs: [0.5, 0.5, obj.geometryArgs?.[1] || 1, 32],
      material: { ...obj.material, color: '#e74c3c' }, // ✅ Red for revolved objects
      position: [...obj.position],
      rotation: [...obj.rotation],
      scale: [...obj.scale],
      visible: true,
      locked: false,
      sourceObject: obj.id // ✅ Track source for undo
    };
    addObject(revolvedObj);
    selectObjects([revolvedObj.id]);
    console.log('✅ Revolve operation completed:', revolvedObj.id);
  };
  // ✅ Improved mirror operation
  const performMirror = async (selectedObjects) => {
    const mirroredObjects = [];
    for (const obj of selectedObjects) {
      const mirroredObj = {
        ...obj,
        id: `${obj.id}_mirror_${Date.now()}`,
        name: `${obj.name}_mirror`,
        position: [-obj.position[0], obj.position[1], obj.position[2]], // ✅ Mirror across YZ plane
        material: {
          ...obj.material,
          opacity: (obj.material?.opacity || 1) * 0.8 // ✅ Slightly transparent for mirrors
        },
        sourceObject: obj.id // ✅ Track source for undo
      };
      addObject(mirroredObj);
      mirroredObjects.push(mirroredObj.id);
    }
    // ✅ Select all mirrored objects
    selectObjects(mirroredObjects);
    console.log(`✅ Mirror operation completed: ${mirroredObjects.length} objects created`);
  };
  return (
    <div className="space-y-3">
      <h3 className="text-white text-sm font-bold">Advanced Operations</h3>
      {/* ✅ Show selection requirements */}
      <div className="text-xs text-gray-400 mb-2">
        Selected: {selectedIds.length} object{selectedIds.length !== 1 ? 's' : ''}
      </div>
      <div className="grid grid-cols-2 gap-2">
        {advancedOps.map((op) => {
          // ✅ Better button state logic
          const isDisabled = (
            (op.type === 'extrude' || op.type === 'revolve') && selectedIds.length !== 1
          ) || (
            (['union', 'subtract', 'intersect'].includes(op.type)) && selectedIds.length < 2
          ) || (
            op.type === 'mirror' && selectedIds.length === 0
          );
          const getTooltip = () => {
            if (op.type === 'extrude' || op.type === 'revolve') return 'Select 1 object';
            if (['union', 'subtract', 'intersect'].includes(op.type)) return 'Select 2+ objects';
            if (op.type === 'mirror') return 'Select any objects';
            return op.name;
          };
          return (
            <button
              key={op.name}
              className={`px-3 py-2 rounded flex flex-col items-center space-y-1 transition-all duration-200 ${
                isDisabled
                  ? 'bg-gray-800 text-gray-500 cursor-not-allowed opacity-50'
                  : 'bg-gray-800 text-gray-200 hover:bg-orange-600 hover:scale-105 active:scale-95'
              }`}
              onClick={() => !isDisabled && performOperation(op.type)}
              disabled={isDisabled}
              title={getTooltip()}
            >
              <span className="text-lg">{op.icon}</span>
              <span className="text-xs">{op.name}</span>
            </button>
          );
        })}
      </div>
      {/* ✅ Help text */}
      <div className="text-xs text-gray-500 mt-2">
        💡 Boolean operations hide source objects. Use layers to organize results.
      </div>
    </div>
  );
};

===== src/components/tools/BooleanOps.jsx =====
import React, { useState } from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import { Geometry, Base, Addition, Subtraction, Intersection } from '@react-three/csg';
import * as THREE from 'three';
export const BooleanOps = () => {
  const { objects, selectedIds } = useScene();
  const { addObject, selectObjects, updateObject } = useSceneActions();
  const [operation, setOperation] = useState('union');
  const [showPanel, setShowPanel] = useState(false);
  const selectedObjects = objects.filter(obj => selectedIds.includes(obj.id));
  const canPerformBoolean = selectedObjects.length >= 2;
  const performBooleanOperation = () => {
    if (!canPerformBoolean) return;
    const [firstObj, secondObj, ...restObjs] = selectedObjects;
    // Calculate the center position of the selected objects
    const positions = selectedObjects.map(obj => new THREE.Vector3(...obj.position));
    const center = positions.reduce((acc, pos) => acc.add(pos), new THREE.Vector3()).divideScalar(positions.length);
    // Create new boolean object
    const newObject = {
      id: `boolean_${Date.now()}`,
      name: `Boolean_${operation}`,
      type: 'boolean',
      operation,
      sourceObjects: selectedIds.slice(), // Use slice to create a copy
      position: [center.x, center.y, center.z],
      rotation: [0, 0, 0],
      scale: [1, 1, 1],
      material: {
        color: '#4a90e2',
        metalness: 0.1,
        roughness: 0.8
      },
      visible: true,
      locked: false
    };
    // Add the boolean object
    addObject(newObject);
    // Hide source objects using updateObject
    selectedIds.forEach(id => {
      updateObject(id, { visible: false });
    });
    // Select the new boolean object
    selectObjects([newObject.id]);
    setShowPanel(false);
  };
  const BooleanGeometry = ({ booleanObj }) => {
    const sourceObjs = objects.filter(obj => booleanObj.sourceObjects.includes(obj.id));
    if (sourceObjs.length < 2) return null;
    const [firstObj, secondObj, ...restObjs] = sourceObjs;
    const getGeometryComponent = (obj) => {
      const { geometry, geometryArgs, position, rotation, scale } = obj;
      const GeomComponent = ({ children, ...props }) => (
        <mesh position={position} rotation={rotation} scale={scale} {...props}>
          {geometry === 'box' && <boxGeometry args={geometryArgs} />}
          {geometry === 'sphere' && <sphereGeometry args={geometryArgs} />}
          {geometry === 'cylinder' && <cylinderGeometry args={geometryArgs} />}
          {geometry === 'cone' && <coneGeometry args={geometryArgs} />}
          {geometry === 'plane' && <planeGeometry args={geometryArgs} />}
          {children}
        </mesh>
      );
      return GeomComponent;
    };
    const FirstGeom = getGeometryComponent(firstObj);
    const SecondGeom = getGeometryComponent(secondObj);
    return (
      <Geometry>
        <Base>
          <FirstGeom />
        </Base>
        {booleanObj.operation === 'union' && (
          <Addition>
            <SecondGeom />
          </Addition>
        )}
        {booleanObj.operation === 'subtract' && (
          <Subtraction>
            <SecondGeom />
          </Subtraction>
        )}
        {booleanObj.operation === 'intersect' && (
          <Intersection>
            <SecondGeom />
          </Intersection>
        )}
        {/* Handle additional objects for complex operations */}
        {restObjs.map((obj, index) => {
          const GeomComponent = getGeometryComponent(obj);
          return (
            <Addition key={index}>
              <GeomComponent />
            </Addition>
          );
        })}
      </Geometry>
    );
  };
  if (!showPanel) {
    return (
      <button
        className={`absolute left-2 top-32 px-3 py-2 rounded text-white ${
          canPerformBoolean ? 'bg-purple-600 hover:bg-purple-700' : 'bg-gray-600 cursor-not-allowed'
        }`}
        onClick={() => canPerformBoolean && setShowPanel(true)}
        disabled={!canPerformBoolean}
        title={canPerformBoolean ? 'Boolean Operations' : 'Select 2+ objects for boolean operations'}
      >
        Boolean Ops
      </button>
    );
  }
  return (
    <>
      <div className="absolute left-2 top-32 w-64 bg-gray-900 bg-opacity-95 text-white p-4 rounded shadow">
        <div className="flex justify-between items-center mb-3">
          <h3 className="text-sm font-bold">Boolean Operations</h3>
          <button
            className="text-gray-400 hover:text-white"
            onClick={() => setShowPanel(false)}
          >
            ✕
          </button>
        </div>
        <div className="mb-4">
          <p className="text-xs text-gray-400 mb-2">
            Selected: {selectedObjects.length} objects
          </p>
          <div className="text-xs text-gray-300">
            {selectedObjects.map(obj => (
              <div key={obj.id} className="truncate">
                • {obj.type || obj.geometry} ({obj.id.slice(0, 8)}...)
              </div>
            ))}
          </div>
        </div>
        <div className="mb-4">
          <label className="block text-xs text-gray-400 mb-2">Operation:</label>
          <div className="flex space-x-1">
            <button
              className={`px-2 py-1 rounded text-xs ${operation === 'union' ? 'bg-purple-600' : 'bg-gray-700'}`}
              onClick={() => setOperation('union')}
            >
              Union
            </button>
            <button
              className={`px-2 py-1 rounded text-xs ${operation === 'subtract' ? 'bg-purple-600' : 'bg-gray-700'}`}
              onClick={() => setOperation('subtract')}
            >
              Subtract
            </button>
            <button
              className={`px-2 py-1 rounded text-xs ${operation === 'intersect' ? 'bg-purple-600' : 'bg-gray-700'}`}
              onClick={() => setOperation('intersect')}
            >
              Intersect
            </button>
          </div>
        </div>
        <div className="space-y-2">
          <button
            className="w-full px-3 py-2 bg-purple-600 text-white rounded hover:bg-purple-700"
            onClick={performBooleanOperation}
          >
            Apply {operation.charAt(0).toUpperCase() + operation.slice(1)}
          </button>
          <button
            className="w-full px-3 py-2 bg-gray-700 text-white rounded hover:bg-gray-600"
            onClick={() => setShowPanel(false)}
          >
            Cancel
          </button>
        </div>
      </div>
    </>
  );
};
// Export the BooleanOps component
export { BooleanOps as default };

===== src/components/tools/ConstraintSystem.jsx =====
import { useState } from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
export function ConstraintSystem() {
  const { selectedObjectId, objects } = useScene();
  const { updateObject } = useSceneActions();
  const [isOpen, setIsOpen] = useState(false);
  const [activeConstraint, setActiveConstraint] = useState(null);
  const selectedObject = objects.find(obj => obj.id === selectedObjectId);
  const constraintTypes = [
    { id: 'distance', name: 'Distance', icon: '📏', description: 'Fix distance between points' },
    { id: 'parallel', name: 'Parallel', icon: '||', description: 'Make lines parallel' },
    { id: 'perpendicular', name: 'Perpendicular', icon: '⊥', description: 'Make lines perpendicular' },
    { id: 'horizontal', name: 'Horizontal', icon: '─', description: 'Make line horizontal' },
    { id: 'vertical', name: 'Vertical', icon: '│', description: 'Make line vertical' },
    { id: 'equal', name: 'Equal', icon: '=', description: 'Make lengths equal' },
    { id: 'concentric', name: 'Concentric', icon: '⊙', description: 'Share same center' },
    { id: 'tangent', name: 'Tangent', icon: '∩', description: 'Make tangent to curve' },
    { id: 'symmetry', name: 'Symmetry', icon: '↔', description: 'Mirror across line' },
    { id: 'angle', name: 'Angle', icon: '∠', description: 'Fix angle between lines' }
  ];
  const applyConstraint = (constraintType) => {
    if (!selectedObjectId) return;
    const newConstraint = {
      id: Date.now().toString(),
      type: constraintType,
      objectId: selectedObjectId,
      value: getDefaultValue(constraintType),
      applied: Date.now()
    };
    const constraints = selectedObject.constraints || [];
    updateObject(selectedObjectId, {
      constraints: [...constraints, newConstraint]
    });
    setActiveConstraint(newConstraint);
  };
  const getDefaultValue = (constraintType) => {
    switch (constraintType) {
      case 'distance': return 1.0;
      case 'angle': return 90;
      case 'horizontal':
      case 'vertical':
      case 'parallel':
      case 'perpendicular':
      case 'equal':
      case 'concentric':
      case 'tangent':
      case 'symmetry':
        return true;
      default: return null;
    }
  };
  const updateConstraintValue = (constraintId, value) => {
    if (!selectedObjectId) return;
    const constraints = selectedObject.constraints || [];
    const updatedConstraints = constraints.map(c =>
      c.id === constraintId ? { ...c, value } : c
    );
    updateObject(selectedObjectId, {
      constraints: updatedConstraints
    });
  };
  const removeConstraint = (constraintId) => {
    if (!selectedObjectId) return;
    const constraints = selectedObject.constraints || [];
    const updatedConstraints = constraints.filter(c => c.id !== constraintId);
    updateObject(selectedObjectId, {
      constraints: updatedConstraints
    });
    if (activeConstraint && activeConstraint.id === constraintId) {
      setActiveConstraint(null);
    }
  };
  const solveConstraints = () => {
    if (!selectedObjectId) return;
    // Constraint solver logic would go here
    // This is a simplified version - in a real app you'd use a proper constraint solver
    console.log('Solving constraints for object:', selectedObjectId);
    // For demo purposes, we'll just show that constraints are being processed
    const constraints = selectedObject.constraints || [];
    console.log(`Processing ${constraints.length} constraints...`);
  };
  if (!selectedObjectId) {
    return (
      <div className="absolute top-60 left-2 z-20">
        <div className="px-3 py-2 bg-gray-700 text-gray-400 rounded-lg shadow-lg text-sm">
          📐 Select a sketch to add constraints
        </div>
      </div>
    );
  }
  if (!isOpen) {
    return (
      <div className="absolute top-60 left-2 z-20">
        <button
          onClick={() => setIsOpen(true)}
          className="px-3 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 shadow-lg"
        >
          📐 Constraints
        </button>
      </div>
    );
  }
  const currentConstraints = selectedObject.constraints || [];
  return (
    <div className="absolute top-60 left-2 z-20 bg-gray-900 text-white p-4 rounded-lg shadow-xl w-80 max-h-96 overflow-y-auto">
      <div className="flex justify-between items-center mb-3">
        <h3 className="text-lg font-semibold">Constraint System</h3>
        <button
          onClick={() => setIsOpen(false)}
          className="text-gray-400 hover:text-white"
        >
          ✕
        </button>
      </div>
      {/* Add Constraints */}
      <div className="mb-4">
        <h4 className="text-sm font-semibold mb-2">Add Constraints</h4>
        <div className="grid grid-cols-2 gap-2">
          {constraintTypes.map(constraint => (
            <button
              key={constraint.id}
              onClick={() => applyConstraint(constraint.id)}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded text-xs flex flex-col items-center"
              title={constraint.description}
            >
              <div className="text-lg mb-1">{constraint.icon}</div>
              <div>{constraint.name}</div>
            </button>
          ))}
        </div>
      </div>
      {/* Current Constraints */}
      {currentConstraints.length > 0 && (
        <div className="mb-4">
          <h4 className="text-sm font-semibold mb-2">Applied Constraints</h4>
          <div className="space-y-2">
            {currentConstraints.map(constraint => {
              const constraintType = constraintTypes.find(t => t.id === constraint.type);
              return (
                <div key={constraint.id} className="flex items-center justify-between p-2 bg-gray-800 rounded">
                  <div className="flex items-center gap-2">
                    <span className="text-lg">{constraintType?.icon}</span>
                    <span className="text-xs">{constraintType?.name}</span>
                    {(constraint.type === 'distance' || constraint.type === 'angle') && (
                      <input
                        type="number"
                        value={constraint.value}
                        onChange={(e) => updateConstraintValue(constraint.id, parseFloat(e.target.value))}
                        className="w-16 px-1 py-0.5 bg-gray-700 text-white text-xs rounded"
                        step={constraint.type === 'angle' ? 1 : 0.1}
                      />
                    )}
                    {constraint.type === 'angle' && <span className="text-xs">°</span>}
                  </div>
                  <button
                    onClick={() => removeConstraint(constraint.id)}
                    className="text-red-400 hover:text-red-300"
                  >
                    ✕
                  </button>
                </div>
              );
            })}
          </div>
        </div>
      )}
      {/* Constraint Actions */}
      <div className="flex gap-2">
        <button
          onClick={solveConstraints}
          disabled={currentConstraints.length === 0}
          className={`flex-1 px-3 py-2 text-sm rounded ${
            currentConstraints.length > 0
              ? 'bg-blue-600 hover:bg-blue-700 text-white'
              : 'bg-gray-700 text-gray-400 cursor-not-allowed'
          }`}
        >
          🔧 Solve ({currentConstraints.length})
        </button>
        {currentConstraints.length > 0 && (
          <button
            onClick={() => updateObject(selectedObjectId, { constraints: [] })}
            className="px-3 py-2 text-sm rounded bg-red-600 hover:bg-red-700 text-white"
          >
            🗑️ Clear All
          </button>
        )}
      </div>
      <div className="mt-4 text-xs text-gray-400">
        💡 Constraints define relationships between sketch elements
      </div>
    </div>
  );
}

===== src/components/tools/ExtrudeRevolve.jsx =====
import React, { useState, useCallback, useMemo } from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import * as THREE from 'three';
export const ExtrudeRevolve = () => {
  const { selectedIds, objects } = useScene();
  const { addObject, selectObjects } = useSceneActions();
  // ✅ Better state management
  const [operation, setOperation] = useState('extrude');
  const [showPanel, setShowPanel] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  // ✅ Parameters with proper defaults
  const [parameters, setParameters] = useState({
    extrudeDepth: 1.0,
    revolveAngle: 360,
    segments: 32,
    steps: 1,
    bevelEnabled: false,
    bevelThickness: 0.1,
    bevelSize: 0.1,
    bevelSegments: 3
  });
  // ✅ Memoized selected objects to prevent unnecessary recalculations
  const selectedObjects = useMemo(() =>
    objects.filter(obj => selectedIds.includes(obj.id)),
    [objects, selectedIds]
  );
  // ✅ Check if operation is possible
  const canExtrude = useMemo(() => {
    if (isProcessing || selectedObjects.length !== 1) return false;
    const obj = selectedObjects[0];
    // ✅ Check for valid 2D sketches or shapes that can be extruded
    return obj && (
      obj.type === 'sketch' ||
      obj.geometry === 'plane' ||
      obj.geometry === 'circle' ||
      (obj.sketchData && obj.sketchData.points)
    );
  }, [selectedObjects, isProcessing]);
  // ✅ Update parameters with validation
  const updateParameter = useCallback((key, value) => {
    setParameters(prev => {
      const newParams = { ...prev };
      // ✅ Validate parameter values
      switch (key) {
        case 'extrudeDepth':
          newParams[key] = Math.max(0.01, Math.min(10, parseFloat(value) || 0.01));
          break;
        case 'revolveAngle':
          newParams[key] = Math.max(1, Math.min(360, parseInt(value) || 1));
          break;
        case 'segments':
          newParams[key] = Math.max(3, Math.min(128, parseInt(value) || 3));
          break;
        case 'steps':
          newParams[key] = Math.max(1, Math.min(10, parseInt(value) || 1));
          break;
        case 'bevelThickness':
        case 'bevelSize':
          newParams[key] = Math.max(0, Math.min(1, parseFloat(value) || 0));
          break;
        case 'bevelSegments':
          newParams[key] = Math.max(1, Math.min(10, parseInt(value) || 1));
          break;
        default:
          newParams[key] = value;
      }
      return newParams;
    });
  }, []);
  // ✅ Create extruded geometry from sketch
  const createExtrudedGeometry = useCallback((sketchObj) => {
    console.log('🏗️ Creating extruded geometry from sketch:', sketchObj.id);
    // ✅ For basic shapes, create appropriate geometry
    if (sketchObj.geometry === 'plane') {
      return {
        geometry: 'box',
        geometryArgs: [
          sketchObj.geometryArgs?.[0] || 2,
          parameters.extrudeDepth,
          sketchObj.geometryArgs?.[1] || 2
        ]
      };
    }
    // ✅ For sketches with point data, create custom extrusion
    if (sketchObj.sketchData && sketchObj.sketchData.points) {
      const points = sketchObj.sketchData.points;
      // ✅ Simple extrusion - convert 2D shape to 3D box for now
      // In a real implementation, you'd use THREE.ExtrudeGeometry
      const bounds = calculateSketchBounds(points);
      return {
        geometry: 'box',
        geometryArgs: [
          bounds.width || 1,
          parameters.extrudeDepth,
          bounds.height || 1
        ]
      };
    }
    // ✅ Fallback geometry
    return {
      geometry: 'box',
      geometryArgs: [2, parameters.extrudeDepth, 2]
    };
  }, [parameters.extrudeDepth]);
  // ✅ Create revolved geometry from sketch
  const createRevolvedGeometry = useCallback((sketchObj) => {
    console.log('🌀 Creating revolved geometry from sketch:', sketchObj.id);
    // ✅ For basic shapes, create appropriate revolution
    if (sketchObj.geometry === 'plane') {
      return {
        geometry: 'cylinder',
        geometryArgs: [
          (sketchObj.geometryArgs?.[0] || 2) / 2, // radiusTop
          (sketchObj.geometryArgs?.[0] || 2) / 2, // radiusBottom
          sketchObj.geometryArgs?.[1] || 2,       // height
          parameters.segments,
          1, // heightSegments
          false, // openEnded
          0, // thetaStart
          (parameters.revolveAngle * Math.PI) / 180 // thetaLength
        ]
      };
    }
    // ✅ For sketches, create cylinder based on bounds
    if (sketchObj.sketchData && sketchObj.sketchData.points) {
      const bounds = calculateSketchBounds(sketchObj.sketchData.points);
      return {
        geometry: 'cylinder',
        geometryArgs: [
          Math.max(0.1, bounds.width / 2 || 0.5),
          Math.max(0.1, bounds.width / 2 || 0.5),
          bounds.height || 1,
          parameters.segments,
          1,
          parameters.revolveAngle < 360, // openEnded if not full revolution
          0,
          (parameters.revolveAngle * Math.PI) / 180
        ]
      };
    }
    // ✅ Fallback geometry
    return {
      geometry: 'cylinder',
      geometryArgs: [0.5, 0.5, 2, parameters.segments]
    };
  }, [parameters.segments, parameters.revolveAngle]);
  // ✅ Calculate bounds of sketch points
  const calculateSketchBounds = useCallback((points) => {
    if (!points || points.length === 0) {
      return { width: 1, height: 1, centerX: 0, centerY: 0 };
    }
    const xs = points.map(p => p[0]);
    const ys = points.map(p => p[1]);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    return {
      width: Math.max(0.1, maxX - minX),
      height: Math.max(0.1, maxY - minY),
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }, []);
  // ✅ Perform the operation with better error handling
  const performOperation = useCallback(async () => {
    if (!canExtrude || selectedObjects.length !== 1) {
      console.warn(`Cannot perform ${operation}: invalid selection`);
      return;
    }
    setIsProcessing(true);
    console.log(`🏗️ Starting ${operation} operation`);
    try {
      const sketchObj = selectedObjects[0];
      // ✅ Create geometry based on operation type
      const geometryData = operation === 'extrude'
        ? createExtrudedGeometry(sketchObj)
        : createRevolvedGeometry(sketchObj);
      // ✅ Create new 3D object
      const newObject = {
        id: `${operation}_${Date.now()}`,
        name: `${sketchObj.name}_${operation}`,
        type: '3d_generated',
        sourceSketch: sketchObj.id,
        operation,
        ...geometryData,
        position: [...sketchObj.position],
        rotation: [0, 0, 0],
        scale: [1, 1, 1],
        material: {
          color: operation === 'extrude' ? '#2ecc71' : '#e74c3c',
          metalness: 0.2,
          roughness: 0.7,
          transparent: false,
          opacity: 1.0
        },
        visible: true,
        locked: false,
        // ✅ Store operation parameters for potential editing
        operationData: {
          type: operation,
          parameters: { ...parameters },
          sourceSketch: sketchObj.id,
          createdAt: Date.now()
        }
      };
      // ✅ Add object and select it
      addObject(newObject);
      selectObjects([newObject.id]);
      console.log(`✅ ${operation} operation completed:`, newObject.id);
      // ✅ Auto-close panel after success
      setTimeout(() => setShowPanel(false), 1000);
    } catch (error) {
      console.error(`❌ ${operation} operation failed:`, error);
      alert(`Failed to ${operation} sketch. Please try again.`);
    } finally {
      setIsProcessing(false);
    }
  }, [canExtrude, selectedObjects, operation, parameters, createExtrudedGeometry, createRevolvedGeometry, addObject, selectObjects]);
  // ✅ Toggle panel with validation
  const togglePanel = () => {
    if (!canExtrude && !showPanel) {
      console.warn('Cannot show extrude/revolve panel: no valid sketch selected');
      return;
    }
    setShowPanel(!showPanel);
  };
  // ✅ Simple button when panel is hidden
  if (!showPanel) {
    return (
      <button
        className={`absolute left-2 top-60 px-4 py-2 rounded-lg text-white font-medium transition-all duration-200 ${
          canExtrude
            ? 'bg-green-600 hover:bg-green-700 hover:scale-105 shadow-lg'
            : 'bg-gray-600 cursor-not-allowed opacity-60'
        }`}
        onClick={togglePanel}
        disabled={!canExtrude}
        title={
          canExtrude
            ? 'Extrude/Revolve sketch to 3D'
            : 'Select a 2D sketch to extrude/revolve'
        }
      >
        <span className="mr-2">🏗️</span>
        Extrude/Revolve
      </button>
    );
  }
  const selectedSketch = selectedObjects[0];
  return (
    <div className="absolute left-2 top-60 w-80 bg-gray-900 bg-opacity-98 text-white p-4 rounded-lg shadow-xl border border-gray-700">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-bold flex items-center">
          <span className="mr-2">🏗️</span>
          3D Generation
        </h3>
        <button
          className="text-gray-400 hover:text-white transition-colors"
          onClick={() => setShowPanel(false)}
        >
          ✕
        </button>
      </div>
      {/* ✅ Selected sketch info */}
      <div className="mb-4 p-3 bg-gray-800 rounded-lg">
        <div className="text-sm font-medium mb-1">Selected Sketch:</div>
        <div className="text-xs text-gray-300">
          {selectedSketch?.name || selectedSketch?.type || 'Unknown'}
          <span className="text-gray-400 ml-2">
            ({selectedSketch?.id.slice(0, 8)}...)
          </span>
        </div>
      </div>
      {/* ✅ Operation selection */}
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-400 mb-2">
          Operation:
        </label>
        <div className="flex space-x-2">
          {[
            { id: 'extrude', name: 'Extrude', icon: '⬆️', desc: 'Push 2D to 3D' },
            { id: 'revolve', name: 'Revolve', icon: '🌀', desc: 'Spin around axis' }
          ].map(op => (
            <button
              key={op.id}
              className={`flex-1 p-3 rounded-lg transition-all duration-200 ${
                operation === op.id
                  ? 'bg-green-600 text-white border-2 border-green-400'
                  : 'bg-gray-700 text-gray-300 hover:bg-gray-600 border-2 border-transparent'
              }`}
              onClick={() => setOperation(op.id)}
            >
              <div className="text-center">
                <div className="text-xl mb-1">{op.icon}</div>
                <div className="text-sm font-medium">{op.name}</div>
                <div className="text-xs opacity-80">{op.desc}</div>
              </div>
            </button>
          ))}
        </div>
      </div>
      {/* ✅ Parameters based on operation */}
      <div className="mb-4 space-y-3">
        <h4 className="text-sm font-medium text-gray-400">Parameters:</h4>
        {operation === 'extrude' && (
          <div>
            <label className="block text-xs text-gray-400 mb-1">
              Depth: {parameters.extrudeDepth.toFixed(2)}
            </label>
            <input
              type="range"
              min="0.01"
              max="5"
              step="0.01"
              value={parameters.extrudeDepth}
              onChange={(e) => updateParameter('extrudeDepth', e.target.value)}
              className="w-full"
            />
          </div>
        )}
        {operation === 'revolve' && (
          <>
            <div>
              <label className="block text-xs text-gray-400 mb-1">
                Angle: {parameters.revolveAngle}°
              </label>
              <input
                type="range"
                min="10"
                max="360"
                step="10"
                value={parameters.revolveAngle}
                onChange={(e) => updateParameter('revolveAngle', e.target.value)}
                className="w-full"
              />
            </div>
            <div>
              <label className="block text-xs text-gray-400 mb-1">
                Segments: {parameters.segments}
              </label>
              <input
                type="range"
                min="3"
                max="64"
                step="1"
                value={parameters.segments}
                onChange={(e) => updateParameter('segments', e.target.value)}
                className="w-full"
              />
            </div>
          </>
        )}
      </div>
      {/* ✅ Action buttons */}
      <div className="space-y-2">
        <button
          className={`w-full px-4 py-3 rounded-lg font-medium transition-all duration-200 ${
            isProcessing
              ? 'bg-yellow-600 text-white cursor-wait'
              : 'bg-green-600 text-white hover:bg-green-700 hover:shadow-lg active:scale-98'
          }`}
          onClick={performOperation}
          disabled={isProcessing}
        >
          {isProcessing ? (
            <span className="flex items-center justify-center">
              <span className="animate-spin mr-2">⚙️</span>
              Generating 3D...
            </span>
          ) : (
            <span>
              {operation === 'extrude' ? '⬆️ Extrude' : '🌀 Revolve'} to 3D
            </span>
          )}
        </button>
        <button
          className="w-full px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-600 transition-colors"
          onClick={() => setShowPanel(false)}
        >
          Cancel
        </button>
      </div>
      {/* ✅ Help text */}
      <div className="mt-4 p-2 bg-green-900 bg-opacity-50 rounded text-xs text-green-200">
        <div className="font-medium mb-1">💡 3D Generation Tips:</div>
        <ul className="space-y-1">
          <li>• Select a 2D sketch or shape first</li>
          <li>• Extrude pushes the shape along its normal</li>
          <li>• Revolve spins the shape around an axis</li>
          <li>• Adjust parameters before generating</li>
        </ul>
      </div>
    </div>
  );
};

===== src/components/tools/PrimitiveTools.jsx =====
// filepath: src/components/tools/PrimitiveTools.jsx
import React from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import * as THREE from 'three';
const primitives = [
  { name: 'Cube', icon: '⬛', type: 'box' },
  { name: 'Sphere', icon: '🟠', type: 'sphere' },
  { name: 'Cylinder', icon: '🗜️', type: 'cylinder' },
  { name: 'Plane', icon: '▭', type: 'plane' },
  { name: 'Cone', icon: '🔺', type: 'cone' },
  { name: 'Boxel', icon: '📦', type: 'boxel' },
];
export const PrimitiveTools = () => {
  const { addObject, selectObjects } = useSceneActions();
  const createPrimitive = (type) => {
    const id = `${type}_${Date.now()}`;
    const position = [0, 0, 0];
    const rotation = [0, 0, 0];
    const scale = [1, 1, 1];
    let geometryArgs;
    switch (type) {
      case 'box':
        geometryArgs = [1, 1, 1];
        break;
      case 'sphere':
        geometryArgs = [0.5, 32, 16];
        break;
      case 'cylinder':
        geometryArgs = [0.5, 0.5, 1, 32];
        break;
      case 'plane':
        geometryArgs = [2, 2];
        break;
      case 'cone':
        geometryArgs = [0.5, 1, 32];
        break;
      case 'boxel':
        geometryArgs = [1]; // Scale for boxel
        break;
      default:
        geometryArgs = [1, 1, 1];
    }
    const obj = {
      id,
      name: `${type}_${primitives.length + 1}`,
      type: 'mesh',
      geometry: type,
      geometryArgs,
      material: {
        type: 'standard',
        color: '#ff6600',
        metalness: 0.1,
        roughness: 0.7,
      },
      position,
      rotation,
      scale,
      visible: true,
      locked: false,
    };
    addObject(obj);
    // Automatically select the newly created object
    selectObjects([id]);
  };
  return (
    <div className="space-y-3">
      <h3 className="text-white text-sm font-bold">Add Primitives</h3>
      <div className="grid grid-cols-2 gap-2">
        {primitives.map((primitive) => (
          <button
            key={primitive.name}
            className="px-3 py-2 rounded flex flex-col items-center space-y-1 bg-gray-800 text-gray-200 hover:bg-orange-600 transition-colors"
            onClick={() => createPrimitive(primitive.type)}
          >
            <span className="text-lg">{primitive.icon}</span>
            <span className="text-xs">{primitive.name}</span>
          </button>
        ))}
      </div>
    </div>
  );
};

===== src/components/tools/SketchCanvas.jsx =====
// filepath: src/components/tools/SketchCanvas.jsx
import React, { useRef, useState } from 'react';
import { useThree } from '@react-three/fiber';
import { useScene } from '../../state/sceneStore.jsx';
import * as THREE from 'three';
export const SketchCanvas = () => {
  const { scene, camera, gl } = useThree();
  const { currentTool } = useScene();
  const [lines, setLines] = useState([]);
  const [isDrawing, setIsDrawing] = useState(false);
  const currentLine = useRef(null);
  const currentRect = useRef(null);
  // Start drawing based on current tool
  const handlePointerDown = (event) => {
    event.stopPropagation();
    setIsDrawing(true);
    switch (currentTool) {
      case 'Line':
      case 'Path':
        startLine(event);
        break;
      case 'Rectangle':
        startRectangle(event);
        break;
      default:
        break;
    }
  };
  const startLine = (event) => {
    const points = [event.point.clone()];
    const material = new THREE.LineBasicMaterial({ color: 'orange' });
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geometry, material);
    scene.add(line);
    currentLine.current = { line, points };
  };
  const startRectangle = (event) => {
    const startPoint = event.point.clone();
    const material = new THREE.LineBasicMaterial({ color: 'orange' });
    const geometry = new THREE.BufferGeometry();
    const line = new THREE.LineLoop(geometry, material);
    scene.add(line);
    currentRect.current = { line, startPoint };
  };
  // Add point to current shape on move
  const handlePointerMove = (event) => {
    if (!isDrawing) return;
    event.stopPropagation();
    switch (currentTool) {
      case 'Line':
      case 'Path':
        updateLine(event);
        break;
      case 'Rectangle':
        updateRectangle(event);
        break;
      default:
        break;
    }
  };
  const updateLine = (event) => {
    if (!currentLine.current) return;
    const point = event.point.clone();
    if (currentTool === 'Path') {
      // For path tool, add points continuously
      currentLine.current.points.push(point);
      currentLine.current.line.geometry.setFromPoints(currentLine.current.points);
    } else {
      // For line tool, just update the end point
      const points = [currentLine.current.points[0], point];
      currentLine.current.line.geometry.setFromPoints(points);
    }
  };
  const updateRectangle = (event) => {
    if (!currentRect.current) return;
    const endPoint = event.point.clone();
    const start = currentRect.current.startPoint;
    const rectPoints = [
      new THREE.Vector3(start.x, start.y, start.z),
      new THREE.Vector3(endPoint.x, start.y, start.z),
      new THREE.Vector3(endPoint.x, endPoint.y, start.z),
      new THREE.Vector3(start.x, endPoint.y, start.z),
    ];
    currentRect.current.line.geometry.setFromPoints(rectPoints);
  };
  // Finish shape on up
  const handlePointerUp = (event) => {
    if (!isDrawing) return;
    event.stopPropagation();
    setIsDrawing(false);
    if (currentLine.current) {
      setLines((prev) => [...prev, currentLine.current.line]);
      currentLine.current = null;
    }
    if (currentRect.current) {
      setLines((prev) => [...prev, currentRect.current.line]);
      currentRect.current = null;
    }
  };
  return (
    <>
      {/* Grid for 2D mode */}
      <gridHelper args={[20, 20, '#444', '#222']} rotation={[0, 0, 0]} />
      {/* invisible plane to capture pointer events */}
      <mesh
        rotation={[-Math.PI / 2, 0, 0]}
        position={[0, 0, 0]}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
      >
        <planeGeometry args={[100, 100]} />
        <meshBasicMaterial visible={false} />
      </mesh>
    </>
  );
};

===== src/components/tools/SketchToolbar.jsx =====
import React from 'react';
import { useScene } from '../../state/sceneStore.jsx';
const tools = [
  { name: 'Line', icon: '📏' },
  { name: 'Rectangle', icon: '⬛' },
  { name: 'Polygon', icon: '🔺' },
  { name: 'Path', icon: '✏️' },
  { name: 'Select', icon: '🖱️' },
];
export const SketchToolbar = () => {
  const { currentTool, setSceneState } = useScene();
  return (
    <div className="absolute top-4 left-1/2 transform -translate-x-1/2 z-10 flex items-center space-x-2 bg-gray-900 bg-opacity-90 p-2 rounded-lg shadow-lg">
      <span className="text-white text-sm mr-2">Draw Tools:</span>
      {tools.map((tool) => (
        <button
          key={tool.name}
          className={`px-3 py-1 rounded flex items-center space-x-1 transition-colors ${
            currentTool === tool.name
              ? 'bg-orange-600 text-white'
              : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
          }`}
          onClick={() => setSceneState({ currentTool: tool.name })}
        >
          <span>{tool.icon}</span>
          <span className="text-sm">{tool.name}</span>
        </button>
      ))}
    </div>
  );
};

===== src/components/ui/AnimationPanel.jsx =====
import { useState, useRef } from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import { useFrame } from '@react-three/fiber';
export function AnimationPanel() {
  const { selectedObjectId, objects } = useScene();
  const { updateObject } = useSceneActions();
  const [isOpen, setIsOpen] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(5);
  const animationRef = useRef();
  const selectedObject = objects.find(obj => obj.id === selectedObjectId);
  const animationTypes = [
    { id: 'rotation', name: 'Rotation', icon: '🔄' },
    { id: 'translation', name: 'Translation', icon: '🔀' },
    { id: 'scale', name: 'Scale', icon: '📏' },
    { id: 'color', name: 'Color', icon: '🎨' },
    { id: 'opacity', name: 'Opacity', icon: '👻' },
    { id: 'custom', name: 'Custom Path', icon: '🛤️' }
  ];
  const easingTypes = [
    { value: 'linear', label: 'Linear' },
    { value: 'easeIn', label: 'Ease In' },
    { value: 'easeOut', label: 'Ease Out' },
    { value: 'easeInOut', label: 'Ease In Out' },
    { value: 'bounce', label: 'Bounce' },
    { value: 'elastic', label: 'Elastic' }
  ];
  const addKeyframe = (animationType) => {
    if (!selectedObjectId) return;
    const animations = selectedObject.animations || [];
    const newKeyframe = {
      id: Date.now().toString(),
      type: animationType,
      time: currentTime,
      value: getDefaultValue(animationType),
      easing: 'linear'
    };
    updateObject(selectedObjectId, {
      animations: [...animations, newKeyframe]
    });
  };
  const getDefaultValue = (type) => {
    switch (type) {
      case 'rotation': return [0, Math.PI * 2, 0]; // Full Y rotation
      case 'translation': return [0, 2, 0]; // Move up 2 units
      case 'scale': return [1.5, 1.5, 1.5]; // Scale to 150%
      case 'color': return '#ff0000'; // Red color
      case 'opacity': return 0.5; // 50% opacity
      case 'custom': return { path: [[0,0,0], [1,1,1], [2,0,0]] };
      default: return null;
    }
  };
  const updateKeyframe = (keyframeId, updates) => {
    if (!selectedObjectId) return;
    const animations = selectedObject.animations || [];
    const updatedAnimations = animations.map(anim =>
      anim.id === keyframeId ? { ...anim, ...updates } : anim
    );
    updateObject(selectedObjectId, {
      animations: updatedAnimations
    });
  };
  const removeKeyframe = (keyframeId) => {
    if (!selectedObjectId) return;
    const animations = selectedObject.animations || [];
    const updatedAnimations = animations.filter(anim => anim.id !== keyframeId);
    updateObject(selectedObjectId, {
      animations: updatedAnimations
    });
  };
  const playAnimation = () => {
    setIsPlaying(true);
    setCurrentTime(0);
  };
  const pauseAnimation = () => {
    setIsPlaying(false);
  };
  const stopAnimation = () => {
    setIsPlaying(false);
    setCurrentTime(0);
  };
  const interpolateValue = (keyframes, time, type) => {
    if (keyframes.length === 0) return null;
    if (keyframes.length === 1) return keyframes[0].value;
    // Sort keyframes by time
    const sortedKeyframes = keyframes.sort((a, b) => a.time - b.time);
    // Find the keyframes to interpolate between
    let startFrame = sortedKeyframes[0];
    let endFrame = sortedKeyframes[sortedKeyframes.length - 1];
    for (let i = 0; i < sortedKeyframes.length - 1; i++) {
      if (time >= sortedKeyframes[i].time && time <= sortedKeyframes[i + 1].time) {
        startFrame = sortedKeyframes[i];
        endFrame = sortedKeyframes[i + 1];
        break;
      }
    }
    // Calculate interpolation factor
    const factor = (time - startFrame.time) / (endFrame.time - startFrame.time);
    // Apply easing
    const easedFactor = applyEasing(factor, endFrame.easing);
    // Interpolate based on type
    switch (type) {
      case 'rotation':
      case 'translation':
      case 'scale':
        return startFrame.value.map((start, index) =>
          start + (endFrame.value[index] - start) * easedFactor
        );
      case 'opacity':
        return startFrame.value + (endFrame.value - startFrame.value) * easedFactor;
      case 'color':
        // Basic color interpolation (would need proper color space conversion in production)
        return easedFactor > 0.5 ? endFrame.value : startFrame.value;
      default:
        return endFrame.value;
    }
  };
  const applyEasing = (t, easing) => {
    switch (easing) {
      case 'linear': return t;
      case 'easeIn': return t * t;
      case 'easeOut': return 1 - (1 - t) * (1 - t);
      case 'easeInOut': return t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);
      case 'bounce': return 1 - Math.abs(Math.cos(t * Math.PI * 3)) * (1 - t);
      case 'elastic': return Math.sin(t * Math.PI * 6) * (1 - t) + t;
      default: return t;
    }
  };
  // Animation loop (this would be handled in the SceneRenderer in a real implementation)
  const AnimationEngine = () => {
    useFrame((state, delta) => {
      if (!isPlaying) return;
      const newTime = currentTime + delta;
      if (newTime >= duration) {
        setCurrentTime(duration);
        setIsPlaying(false);
        return;
      }
      setCurrentTime(newTime);
      // Apply animations to selected object
      if (selectedObject && selectedObject.animations) {
        const rotationFrames = selectedObject.animations.filter(a => a.type === 'rotation');
        const translationFrames = selectedObject.animations.filter(a => a.type === 'translation');
        const scaleFrames = selectedObject.animations.filter(a => a.type === 'scale');
        const newRotation = interpolateValue(rotationFrames, newTime, 'rotation');
        const newTranslation = interpolateValue(translationFrames, newTime, 'translation');
        const newScale = interpolateValue(scaleFrames, newTime, 'scale');
        const updates = {};
        if (newRotation) updates.rotation = newRotation;
        if (newTranslation) updates.position = newTranslation;
        if (newScale) updates.scale = newScale;
        if (Object.keys(updates).length > 0) {
          updateObject(selectedObjectId, updates);
        }
      }
    });
    return null;
  };
  if (!selectedObjectId) {
    return (
      <div className="absolute bottom-40 left-2 z-20">
        <div className="px-3 py-2 bg-gray-700 text-gray-400 rounded-lg shadow-lg text-sm">
          🎬 Select an object to animate
        </div>
      </div>
    );
  }
  if (!isOpen) {
    return (
      <div className="absolute bottom-40 left-2 z-20">
        <button
          onClick={() => setIsOpen(true)}
          className="px-3 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 shadow-lg"
        >
          🎬 Animation
        </button>
      </div>
    );
  }
  const currentAnimations = selectedObject.animations || [];
  return (
    <>
      <AnimationEngine />
      <div className="absolute bottom-40 left-2 z-20 bg-gray-900 text-white p-4 rounded-lg shadow-xl w-80 max-h-96 overflow-y-auto">
        <div className="flex justify-between items-center mb-3">
          <h3 className="text-lg font-semibold">Animation Panel</h3>
          <button
            onClick={() => setIsOpen(false)}
            className="text-gray-400 hover:text-white"
          >
            ✕
          </button>
        </div>
        {/* Timeline Controls */}
        <div className="mb-4 p-3 bg-gray-800 rounded">
          <div className="flex justify-between items-center mb-2">
            <span className="text-sm">Timeline</span>
            <span className="text-xs">{currentTime.toFixed(1)}s / {duration}s</span>
          </div>
          <input
            type="range"
            min="0"
            max={duration}
            step="0.1"
            value={currentTime}
            onChange={(e) => setCurrentTime(parseFloat(e.target.value))}
            className="w-full mb-2"
          />
          <div className="flex gap-2 mb-2">
            <button
              onClick={playAnimation}
              disabled={isPlaying}
              className="px-2 py-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 rounded text-xs"
            >
              ▶️ Play
            </button>
            <button
              onClick={pauseAnimation}
              disabled={!isPlaying}
              className="px-2 py-1 bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 rounded text-xs"
            >
              ⏸️ Pause
            </button>
            <button
              onClick={stopAnimation}
              className="px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-xs"
            >
              ⏹️ Stop
            </button>
          </div>
          <div>
            <label className="text-xs block mb-1">Duration: {duration}s</label>
            <input
              type="range"
              min="1"
              max="60"
              value={duration}
              onChange={(e) => setDuration(parseInt(e.target.value))}
              className="w-full"
            />
          </div>
        </div>
        {/* Add Keyframes */}
        <div className="mb-4">
          <h4 className="text-sm font-semibold mb-2">Add Keyframe at {currentTime.toFixed(1)}s</h4>
          <div className="grid grid-cols-3 gap-2">
            {animationTypes.map(type => (
              <button
                key={type.id}
                onClick={() => addKeyframe(type.id)}
                className="p-2 bg-gray-800 hover:bg-gray-700 rounded text-xs flex flex-col items-center"
              >
                <div className="text-lg mb-1">{type.icon}</div>
                <div>{type.name}</div>
              </button>
            ))}
          </div>
        </div>
        {/* Current Keyframes */}
        {currentAnimations.length > 0 && (
          <div className="space-y-2">
            <h4 className="text-sm font-semibold">Keyframes</h4>
            {currentAnimations.map(anim => {
              const animType = animationTypes.find(t => t.id === anim.type);
              return (
                <div key={anim.id} className="p-2 bg-gray-800 rounded">
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-2">
                      <span>{animType?.icon}</span>
                      <span className="text-xs">{animType?.name}</span>
                      <span className="text-xs text-gray-400">@{anim.time.toFixed(1)}s</span>
                    </div>
                    <button
                      onClick={() => removeKeyframe(anim.id)}
                      className="text-red-400 hover:text-red-300"
                    >
                      ✕
                    </button>
                  </div>
                  <div className="space-y-1">
                    <div>
                      <label className="text-xs block">Time:</label>
                      <input
                        type="number"
                        value={anim.time}
                        onChange={(e) => updateKeyframe(anim.id, { time: parseFloat(e.target.value) })}
                        className="w-full px-1 py-0.5 bg-gray-700 text-white text-xs rounded"
                        step="0.1"
                        min="0"
                        max={duration}
                      />
                    </div>
                    <div>
                      <label className="text-xs block">Easing:</label>
                      <select
                        value={anim.easing}
                        onChange={(e) => updateKeyframe(anim.id, { easing: e.target.value })}
                        className="w-full bg-gray-700 text-white text-xs rounded p-1"
                      >
                        {easingTypes.map(easing => (
                          <option key={easing.value} value={easing.value}>
                            {easing.label}
                          </option>
                        ))}
                      </select>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        )}
        <div className="mt-4 text-xs text-gray-400">
          💡 Create keyframes to animate object properties over time
        </div>
      </div>
    </>
  );
}

===== src/components/ui/BoxelInfo.jsx =====
export const BoxelInfo = () => {
    return (
        <div className={'pointer-events-none gloww absolute flex flex-col justify-center text-orange-500 p-2 px-3 text-xl'}>
            <div className={'flex'}>
                <div className={'w-6 h-6 min-w-6 bg-orange-400 mt-1.5 mr-1.5 rounded-sm'}></div>
                <span className={'opacity-80 pr-1.5 pt-1'}><i>the</i></span> "<span className={'text-orange-400 text-3xl hover:text-lime-400 pointer-events-auto cursor-crosshair'}>boxel</span>"
            </div>
            <div className={'text-md w-[200px] flex flex-col'}>
                <div>
                    a <span className={'text-orange-300'}>faceted cube</span> with multiple shapes, all in one geometry!
                </div>
                <div className={'text-sm text-orange-300 pt-2 opacity-80'}>
                    the 'angle' shader attribute moves the vertices along their normals
                </div>
            </div>
        </div>
    )
}

===== src/components/ui/ExportPanel.jsx =====
// filepath: src/components/ui/ExportPanel.jsx
import React, { useState } from 'react';
import { useScene } from '../../state/sceneStore.jsx';
import { exportAsJSX, exportAsJSON } from '../../utils/exportScene';
import { undoRedoManager } from '../../utils/undoRedo';
export const ExportPanel = ({ onLoadInViewer }) => {
  const { objects } = useScene();
  const [format, setFormat] = useState('jsx');
  const [exportCode, setExportCode] = useState('');
  const [importCode, setImportCode] = useState('');
  const handleExport = () => {
    const code = format === 'jsx' ? exportAsJSX(objects) : exportAsJSON(objects);
    setExportCode(code);
  };
  const copyToClipboard = () => {
    navigator.clipboard.writeText(exportCode);
  };
  const loadInViewer = () => {
    if (exportCode && onLoadInViewer) {
      onLoadInViewer(exportCode);
    }
  };
  const handleImport = () => {
    try {
      const sceneData = JSON.parse(importCode);
      if (sceneData && Array.isArray(sceneData.objects)) {
        // Save current state for undo
        undoRedoManager.saveState({
          objects: objects,
          selectedIds: [],
          selectedObjectId: null
        }, 'Before Import');
        // Load the imported scene
        setSceneState({
          objects: sceneData.objects,
          selectedIds: [],
          selectedObjectId: null
        });
        setImportCode('');
        alert('Scene imported successfully!');
      } else {
        alert('Invalid scene data format');
      }
    } catch (error) {
      alert('Error parsing scene data: ' + error.message);
    }
  };
  if (!showPanel) {
    return (
      <button
        className="absolute bottom-2 right-2 px-3 py-2 bg-orange-600 text-white rounded hover:bg-orange-700"
        onClick={() => setShowPanel(true)}
      >
        Export Scene
      </button>
    );
  }
  return (
    <div className="absolute bottom-2 right-2 w-96 bg-gray-900 bg-opacity-95 text-white p-4 rounded shadow">
      <div className="flex justify-between items-center mb-3">
        <h3 className="text-sm font-bold">Export Scene</h3>
        <button
          className="text-gray-400 hover:text-white"
          onClick={() => setShowPanel(false)}
        >
          ✕
        </button>
      </div>
      <div className="flex space-x-2 mb-3">
        <button
          className={`px-2 py-1 rounded text-xs ${format === 'jsx' ? 'bg-orange-600' : 'bg-gray-700'}`}
          onClick={() => setFormat('jsx')}
        >
          JSX
        </button>
        <button
          className={`px-2 py-1 rounded text-xs ${format === 'json' ? 'bg-orange-600' : 'bg-gray-700'}`}
          onClick={() => setFormat('json')}
        >
          JSON
        </button>
      </div>
      <button
        className="w-full px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 mb-3"
        onClick={handleExport}
      >
        Generate {format.toUpperCase()} Code
      </button>
      {exportCode && (
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <span className="text-xs text-gray-400">Generated Code:</span>
            <div className="flex space-x-1">
              <button
                className="px-2 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700"
                onClick={copyToClipboard}
              >
                Copy
              </button>
              {format === 'json' && (
                <button
                  className="px-2 py-1 bg-purple-600 text-white rounded text-xs hover:bg-purple-700"
                  onClick={loadInViewer}
                >
                  View
                </button>
              )}
            </div>
          </div>
          <textarea
            className="w-full h-32 bg-gray-800 text-white p-2 rounded text-xs font-mono"
            value={exportCode}
            readOnly
          />
        </div>
      )}
    </div>
  );
};

===== src/components/ui/ExportPanel_sidebar.jsx =====
// Simplified Export panel for sidebar
import React, { useState } from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import { exportAsJSX, exportAsJSON } from '../../utils/exportScene';
export const ExportPanel = ({ onLoadInViewer }) => {
  const { objects } = useScene();
  const [format, setFormat] = useState('jsx');
  const [exportCode, setExportCode] = useState('');
  const handleExport = () => {
    const code = format === 'jsx' ? exportAsJSX(objects) : exportAsJSON(objects);
    setExportCode(code);
  };
  const copyToClipboard = () => {
    navigator.clipboard.writeText(exportCode);
  };
  const loadInViewer = () => {
    if (exportCode && onLoadInViewer) {
      onLoadInViewer(exportCode);
    }
  };
  return (
    <div className="space-y-4">
      <h3 className="text-white text-sm font-bold">Export Scene</h3>
      <div className="flex space-x-2">
        <button
          className={`px-3 py-1 rounded text-xs ${format === 'jsx' ? 'bg-orange-600' : 'bg-gray-700'}`}
          onClick={() => setFormat('jsx')}
        >
          JSX
        </button>
        <button
          className={`px-3 py-1 rounded text-xs ${format === 'json' ? 'bg-orange-600' : 'bg-gray-700'}`}
          onClick={() => setFormat('json')}
        >
          JSON
        </button>
      </div>
      <button
        className="w-full px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700"
        onClick={handleExport}
        disabled={objects.length === 0}
      >
        Generate {format.toUpperCase()} Code
      </button>
      {exportCode && (
        <div className="space-y-2">
          <div className="flex space-x-2">
            <button
              className="flex-1 px-2 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700"
              onClick={copyToClipboard}
            >
              Copy
            </button>
            {format === 'jsx' && (
              <button
                className="flex-1 px-2 py-1 bg-purple-600 text-white rounded text-xs hover:bg-purple-700"
                onClick={loadInViewer}
              >
                View
              </button>
            )}
          </div>
          <textarea
            className="w-full h-24 bg-gray-800 text-white p-2 rounded text-xs font-mono"
            value={exportCode}
            readOnly
          />
        </div>
      )}
      {objects.length === 0 && (
        <div className="text-gray-400 text-center py-4">
          <div className="text-2xl mb-2">📤</div>
          <p className="text-xs">Add objects to export</p>
        </div>
      )}
    </div>
  );
};

===== src/components/ui/GizmoControls.jsx =====
import React, { useCallback, useRef } from 'react';
import { TransformControls } from '@react-three/drei';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
export const GizmoControls = ({ selectedMesh, onDraggingChanged }) => {
  const { transformMode, selectedObjectId } = useScene();
  const { updateObject } = useSceneActions();
  const transformRef = useRef();
  const isDragging = useRef(false);
  // ✅ Handle dragging state change events with better state management
  const handleDraggingChanged = useCallback((event) => {
    const newIsDragging = event.value;
    isDragging.current = newIsDragging;
    console.log('🎮 Transform dragging changed:', newIsDragging);
    // ✅ More robust camera control management
    if (window.cam) {
      window.cam.enabled = !newIsDragging;
      // ✅ Ensure camera doesn't interfere during transform
      if (newIsDragging) {
        // Disable any auto-rotation or camera animations
        window.cam.dampingFactor = 0.25; // Slower damping during transform
      } else {
        // Restore normal camera behavior
        window.cam.dampingFactor = 0.05;
      }
    }
    // Notify parent component
    if (onDraggingChanged) {
      onDraggingChanged(newIsDragging);
    }
  }, [onDraggingChanged]);
  // ✅ Handle object transformation with immediate updates
  const handleObjectChange = useCallback((event) => {
    if (!selectedObjectId || !event?.target?.object || !isDragging.current) return;
    const object = event.target.object;
    console.log('🔄 Transform update:', {
      position: [object.position.x, object.position.y, object.position.z],
      rotation: [object.rotation.x, object.rotation.y, object.rotation.z],
      scale: [object.scale.x, object.scale.y, object.scale.z]
    });
    // ✅ Immediate update during drag for responsive feel
    updateObject(selectedObjectId, {
      position: [
        Math.round(object.position.x * 1000) / 1000, // Round to avoid floating point issues
        Math.round(object.position.y * 1000) / 1000,
        Math.round(object.position.z * 1000) / 1000
      ],
      rotation: [
        Math.round(object.rotation.x * 1000) / 1000,
        Math.round(object.rotation.y * 1000) / 1000,
        Math.round(object.rotation.z * 1000) / 1000
      ],
      scale: [
        Math.max(0.01, Math.round(object.scale.x * 1000) / 1000), // Prevent zero/negative scale
        Math.max(0.01, Math.round(object.scale.y * 1000) / 1000),
        Math.max(0.01, Math.round(object.scale.z * 1000) / 1000)
      ]
    });
  }, [selectedObjectId, updateObject]);
  // ✅ Handle mouse events for better interaction
  const handleMouseDown = useCallback(() => {
    if (transformRef.current) {
      console.log('🎯 Transform controls activated');
    }
  }, []);
  const handleMouseUp = useCallback(() => {
    if (transformRef.current && isDragging.current) {
      console.log('🎯 Transform controls deactivated');
      // Force final update to ensure state consistency
      if (selectedMesh && selectedObjectId) {
        handleObjectChange({ target: { object: selectedMesh } });
      }
    }
  }, [selectedMesh, selectedObjectId, handleObjectChange]);
  // Don't render if no mesh is selected
  if (!selectedMesh || !selectedObjectId) {
    return null;
  }
  return (
    <TransformControls
      ref={transformRef}
      object={selectedMesh}
      mode={transformMode || 'translate'}
      onObjectChange={handleObjectChange}
      onDraggingChanged={handleDraggingChanged}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      // ✅ Transform controls configuration
      showX={true}
      showY={true}
      showZ={true}
      space="world"
      size={1.2} // Slightly larger for easier interaction
      enabled={true}
      visible={true}
      // ✅ Improve gizmo appearance
      lineWidth={3}
      // ✅ Snap settings if needed
      translationSnap={window.scene?.snapToGrid ? window.scene?.gridSize || 0.5 : null}
      rotationSnap={Math.PI / 12} // 15 degree snaps
      scaleSnap={0.1}
    />
  );
};

===== src/components/ui/GroupManager.jsx =====
import { useScene } from '../../state/sceneStore.jsx';
export function GroupManager() {
  const { objects, selectedIds, groups = [] } = useScene();
  // Temporarily disable group functions during migration
  const createGroup = () => console.log('Group management temporarily disabled');
  const ungroupObjects = () => console.log('Group management temporarily disabled');
  const addObjectToGroup = () => console.log('Group management temporarily disabled');
  const removeObjectFromGroup = () => console.log('Group management temporarily disabled');
  const handleCreateGroup = () => {
    if (selectedIds.length >= 2) {
      createGroup(selectedIds, `Group ${groups.length + 1}`);
    }
  };
  const handleUngroup = (groupId) => {
    ungroupObjects(groupId);
  };
  const selectedObjects = objects.filter(obj => selectedIds.includes(obj.id));
  const canGroup = selectedIds.length >= 2;
  const selectedGroups = groups.filter(group =>
    selectedIds.some(id => group.objectIds.includes(id))
  );
  return (
    <div className="absolute bottom-2 left-2 z-20 bg-gray-900 text-white p-3 rounded-lg shadow-xl">
      <h4 className="text-sm font-semibold mb-2">Group Operations</h4>
      <div className="flex gap-2 mb-2">
        <button
          onClick={handleCreateGroup}
          disabled={!canGroup}
          className={`px-3 py-1 text-xs rounded ${
            canGroup
              ? 'bg-blue-600 hover:bg-blue-700 text-white'
              : 'bg-gray-700 text-gray-400 cursor-not-allowed'
          }`}
          title={`Group ${selectedIds.length} selected objects`}
        >
          📦 Group ({selectedIds.length})
        </button>
        {selectedGroups.length > 0 && (
          <button
            onClick={() => selectedGroups.forEach(group => handleUngroup(group.id))}
            className="px-3 py-1 text-xs rounded bg-orange-600 hover:bg-orange-700 text-white"
            title={`Ungroup ${selectedGroups.length} groups`}
          >
            📤 Ungroup ({selectedGroups.length})
          </button>
        )}
      </div>
      {/* Active groups display */}
      {groups.length > 0 && (
        <div className="space-y-1">
          <div className="text-xs text-gray-400">Active Groups:</div>
          {groups.map(group => (
            <div key={group.id} className="flex items-center justify-between text-xs bg-gray-800 p-1 rounded">
              <span>{group.name} ({group.objectIds.length} objects)</span>
              <button
                onClick={() => handleUngroup(group.id)}
                className="text-red-400 hover:text-red-300 ml-2"
                title="Ungroup"
              >
                ✕
              </button>
            </div>
          ))}
        </div>
      )}
      <div className="text-xs text-gray-400 mt-2">
        💡 Select 2+ objects to create a group
      </div>
    </div>
  );
}

===== src/components/ui/LayerManager.jsx =====
import { useState } from 'react';
import { useScene } from '../../state/sceneStore.jsx';
export function LayerManager() {
  const { layers, objects } = useScene();
  const [newLayerName, setNewLayerName] = useState('');
  // Temporarily disable layer functions during migration
  const addLayer = () => console.log('Layer management temporarily disabled');
  const deleteLayer = () => console.log('Layer management temporarily disabled');
  const updateLayer = () => console.log('Layer management temporarily disabled');
  const moveObjectToLayer = () => console.log('Layer management temporarily disabled');
  const toggleLayerVisibility = () => console.log('Layer management temporarily disabled');
  const [isExpanded, setIsExpanded] = useState(false);
  const handleAddLayer = () => {
    if (newLayerName.trim()) {
      addLayer({
        id: Date.now().toString(),
        name: newLayerName.trim(),
        visible: true,
        locked: false,
        color: `#${Math.floor(Math.random()*16777215).toString(16)}`
      });
      setNewLayerName('');
    }
  };
  const handleDeleteLayer = (layerId) => {
    if (layers.length > 1) { // Keep at least one layer
      deleteLayer(layerId);
    }
  };
  const handleDragStart = (e, objectId) => {
    e.dataTransfer.setData('text/plain', objectId);
  };
  const handleDragOver = (e) => {
    e.preventDefault();
  };
  const handleDrop = (e, layerId) => {
    e.preventDefault();
    const objectId = e.dataTransfer.getData('text/plain');
    moveObjectToLayer(objectId, layerId);
  };
  const getObjectsInLayer = (layerId) => {
    return objects.filter(obj => obj.layerId === layerId);
  };
  if (!isExpanded) {
    return (
      <div className="absolute top-20 right-2 z-20">
        <button
          onClick={() => setIsExpanded(true)}
          className="px-3 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 shadow-lg"
        >
          📁 Layers
        </button>
      </div>
    );
  }
  return (
    <div className="absolute top-20 right-2 z-20 bg-gray-900 text-white p-4 rounded-lg shadow-xl w-80 max-h-96 overflow-y-auto">
      <div className="flex justify-between items-center mb-3">
        <h3 className="text-lg font-semibold">Layer Manager</h3>
        <button
          onClick={() => setIsExpanded(false)}
          className="text-gray-400 hover:text-white"
        >
          ✕
        </button>
      </div>
      {/* Add new layer */}
      <div className="mb-4 flex gap-2">
        <input
          type="text"
          value={newLayerName}
          onChange={(e) => setNewLayerName(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && handleAddLayer()}
          placeholder="New layer name"
          className="flex-1 px-2 py-1 bg-gray-700 text-white rounded border border-gray-600 focus:border-orange-500 outline-none"
        />
        <button
          onClick={handleAddLayer}
          className="px-3 py-1 bg-orange-600 text-white rounded hover:bg-orange-700"
        >
          +
        </button>
      </div>
      {/* Layer list */}
      <div className="space-y-2">
        {layers.map(layer => {
          const layerObjects = getObjectsInLayer(layer.id);
          return (
            <div
              key={layer.id}
              className="border border-gray-700 rounded p-2"
              onDragOver={handleDragOver}
              onDrop={(e) => handleDrop(e, layer.id)}
            >
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2 flex-1">
                  <div
                    className="w-4 h-4 rounded border border-gray-600"
                    style={{ backgroundColor: layer.color }}
                  />
                  <span className="text-sm font-medium">{layer.name}</span>
                  <span className="text-xs text-gray-400">({layerObjects.length})</span>
                </div>
                <div className="flex gap-1">
                  <button
                    onClick={() => toggleLayerVisibility(layer.id)}
                    className={`text-xs px-2 py-1 rounded ${
                      layer.visible ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-600 hover:bg-gray-700'
                    }`}
                    title={layer.visible ? 'Hide layer' : 'Show layer'}
                  >
                    {layer.visible ? '👁️' : '🙈'}
                  </button>
                  <button
                    onClick={() => updateLayer(layer.id, { locked: !layer.locked })}
                    className={`text-xs px-2 py-1 rounded ${
                      layer.locked ? 'bg-red-600 hover:bg-red-700' : 'bg-gray-600 hover:bg-gray-700'
                    }`}
                    title={layer.locked ? 'Unlock layer' : 'Lock layer'}
                  >
                    {layer.locked ? '🔒' : '🔓'}
                  </button>
                  {layers.length > 1 && (
                    <button
                      onClick={() => handleDeleteLayer(layer.id)}
                      className="text-xs px-2 py-1 rounded bg-red-600 hover:bg-red-700"
                      title="Delete layer"
                    >
                      🗑️
                    </button>
                  )}
                </div>
              </div>
              {/* Objects in layer */}
              {layerObjects.length > 0 && (
                <div className="ml-4 space-y-1">
                  {layerObjects.map(obj => (
                    <div
                      key={obj.id}
                      draggable
                      onDragStart={(e) => handleDragStart(e, obj.id)}
                      className="flex items-center justify-between p-1 bg-gray-800 rounded text-xs cursor-move hover:bg-gray-700"
                    >
                      <span>{obj.type || obj.geometry} - {obj.id.slice(0, 8)}</span>
                      {obj.material && (
                        <div
                          className="w-3 h-3 rounded border border-gray-600"
                          style={{ backgroundColor: obj.material.color || '#ffffff' }}
                        />
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        })}
      </div>
      <div className="mt-4 text-xs text-gray-400">
        💡 Drag objects between layers to organize your scene
      </div>
    </div>
  );
}

===== src/components/ui/MaterialEditor.jsx =====
import { useState, useEffect, useCallback } from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
// Simple debounce function to limit state updates
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}
export const MaterialEditor = () => {
  const { selectedObjectId, objects, selectedIds } = useScene();
  const { updateObject } = useSceneActions();
  const [localMaterial, setLocalMaterial] = useState({});
  const [localAngle, setLocalAngle] = useState(0.1);
  // Get the currently selected object
  const selectedObject = selectedObjectId ? objects.find(obj => obj.id === selectedObjectId) :
                         selectedIds.length > 0 ? objects.find(obj => obj.id === selectedIds[0]) : null;
  // Update local material state when selection changes
  useEffect(() => {
    if (selectedObject && selectedObject.material) {
      setLocalMaterial({...selectedObject.material});
      // Set angle from object if available
      setLocalAngle(selectedObject.angle || 0.1);
    } else {
      setLocalMaterial({
        color: '#808080',
        metalness: 0.1,
        roughness: 0.8,
        opacity: 1.0,
        emissive: '#000000',
        emissiveIntensity: 0
      });
      setLocalAngle(0.1);
    }
  }, [selectedObject, selectedObjectId, selectedIds]);
  // Debounced update to prevent too many state changes - reduced delay for better responsiveness
  const debouncedUpdate = useCallback(
    debounce((id, updates) => {
      updateObject(id, updates);
    }, 16), // Reduced from 100ms to 16ms (60fps) for more responsive updates
    []
  );
  // Update angle with debouncing
  const updateAngle = (value) => {
    if (!selectedObject) return;
    // Update local state immediately for responsive UI
    setLocalAngle(value);
    // Update object in store with debouncing
    debouncedUpdate(selectedObject.id, { angle: value });
  };
  const updateMaterial = (property, value) => {
    if (!selectedObject) return;
    // Update local state immediately for responsive UI
    setLocalMaterial(prev => {
      const newMaterial = { ...prev, [property]: value };
      // Only send update to store after a small delay
      debouncedUpdate(selectedObject.id, { material: newMaterial });
      return newMaterial;
    });
  };
  // The updateAngle function is already defined above
  if (!selectedObject) {
    return (
      <div className="text-gray-400 text-center py-8">
        <div className="text-4xl mb-2">🎨</div>
        <p>Select an object to edit materials</p>
      </div>
    );
  }
  const material = selectedObject?.material || {};
  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h3 className="text-white text-sm font-bold">Material Editor</h3>
      </div>
      <div className="mb-4">
        <p className="text-xs text-gray-400 mb-2">
          Object: {selectedObject?.type || selectedObject?.geometry} ({selectedObject?.id.slice(0, 8)}...)
        </p>
      </div>
      {/* Color */}
      <div className="mb-4">
        <label className="block text-xs text-gray-400 mb-2">Color:</label>
        <div className="flex items-center space-x-2">
          <input
            type="color"
            value={material.color || '#808080'}
            onChange={(e) => updateMaterial('color', e.target.value)}
            className="w-8 h-8 rounded border border-gray-600"
          />
          <input
            type="text"
            value={material.color || '#808080'}
            onChange={(e) => updateMaterial('color', e.target.value)}
            className="flex-1 px-2 py-1 bg-gray-800 text-white rounded text-xs"
            placeholder="#808080"
          />
        </div>
      </div>
      {/* Metalness */}
      <div className="mb-4">
        <label className="block text-xs text-gray-400 mb-1">
          Metalness: {(material.metalness || 0.1).toFixed(2)}
        </label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value={material.metalness || 0.1}
          onChange={(e) => updateMaterial('metalness', parseFloat(e.target.value))}
          className="w-full"
        />
      </div>
      {/* Roughness */}
      <div className="mb-4">
        <label className="block text-xs text-gray-400 mb-1">
          Roughness: {(material.roughness || 0.8).toFixed(2)}
        </label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value={material.roughness || 0.8}
          onChange={(e) => updateMaterial('roughness', parseFloat(e.target.value))}
          className="w-full"
        />
      </div>
      {/* Opacity */}
      <div className="mb-4">
        <label className="block text-xs text-gray-400 mb-1">
          Opacity: {(material.opacity || 1.0).toFixed(2)}
        </label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value={material.opacity || 1.0}
          onChange={(e) => updateMaterial('opacity', parseFloat(e.target.value))}
          className="w-full"
        />
      </div>
      {/* Emissive */}
      <div className="mb-4">
        <label className="block text-xs text-gray-400 mb-2">Emissive:</label>
        <div className="flex items-center space-x-2">
          <input
            type="color"
            value={material.emissive || '#000000'}
            onChange={(e) => updateMaterial('emissive', e.target.value)}
            className="w-8 h-8 rounded border border-gray-600"
          />
          <input
            type="text"
            value={material.emissive || '#000000'}
            onChange={(e) => updateMaterial('emissive', e.target.value)}
            className="flex-1 px-2 py-1 bg-gray-800 text-white rounded text-xs"
            placeholder="#000000"
          />
        </div>
      </div>
      {/* Emissive Intensity */}
      <div className="mb-4">
        <label className="block text-xs text-gray-400 mb-1">
          Emissive Intensity: {(material.emissiveIntensity || 0.0).toFixed(2)}
        </label>
        <input
          type="range"
          min="0"
          max="2"
          step="0.01"
          value={material.emissiveIntensity || 0.0}
          onChange={(e) => updateMaterial('emissiveIntensity', parseFloat(e.target.value))}
          className="w-full"
        />
      </div>
      {/* Shape Angle Modifier */}
      <div className="mb-4">
        <label className="block text-xs text-gray-400 mb-1">
          Shape Angle: {localAngle.toFixed(2)}
        </label>
        <input
          type="range"
          min="0.01"
          max="0.99"
          step="0.01"
          value={localAngle}
          onChange={(e) => updateAngle(parseFloat(e.target.value))}
          className="w-full"
        />
        <p className="text-xs text-gray-500 mt-1">Modifies the shape's angles and curves</p>
      </div>
      {/* Material Presets */}
      <div className="mb-4">
        <label className="block text-xs text-gray-400 mb-2">Presets:</label>
        <div className="grid grid-cols-2 gap-1">
          <button
            className="px-2 py-1 bg-gray-700 text-white rounded text-xs hover:bg-gray-600"
            onClick={() => {
              // Apply plastic preset all at once
              const newMaterial = {
                ...selectedObject.material,
                color: '#808080',
                metalness: 0.0,
                roughness: 0.9
              };
              updateObject(selectedObject.id, { material: newMaterial });
            }}
          >
            Plastic
          </button>
          <button
            className="px-2 py-1 bg-gray-700 text-white rounded text-xs hover:bg-gray-600"
            onClick={() => {
              // Apply metal preset all at once
              const newMaterial = {
                ...selectedObject.material,
                color: '#c0c0c0',
                metalness: 1.0,
                roughness: 0.2
              };
              updateObject(selectedObject.id, { material: newMaterial });
            }}
          >
            Metal
          </button>
          <button
            className="px-2 py-1 bg-gray-700 text-white rounded text-xs hover:bg-gray-600"
            onClick={() => {
              // Apply wood preset all at once
              const newMaterial = {
                ...selectedObject.material,
                color: '#8B4513',
                metalness: 0.0,
                roughness: 0.8
              };
              updateObject(selectedObject.id, { material: newMaterial });
            }}
          >
            Wood
          </button>
          <button
            className="px-2 py-1 bg-gray-700 text-white rounded text-xs hover:bg-gray-600"
            onClick={() => {
              updateMaterial('color', '#ffffff');
              updateMaterial('metalness', 0.0);
              updateMaterial('roughness', 0.1);
              updateMaterial('opacity', 0.3);
            }}
          >
            Glass
          </button>
        </div>
      </div>
    </div>
  );
};

===== src/components/ui/ObjectManager.jsx =====
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
export const ObjectManager = () => {
  const { objects, selectedIds, setSceneState } = useScene();
  const { selectObjects, deleteObject: removeObject } = useSceneActions();
  const toggleVisibility = (id) => {
    setSceneState((prev) => ({
      objects: prev.objects.map((obj) =>
        obj.id === id ? { ...obj, visible: !obj.visible } : obj
      ),
    }));
  };
  const toggleLock = (id) => {
    setSceneState((prev) => ({
      objects: prev.objects.map((obj) =>
        obj.id === id ? { ...obj, locked: !obj.locked } : obj
      ),
    }));
  };
  const deleteObject = (id) => {
    removeObject(id);
  };
  const selectObject = (id) => {
    selectObjects([id]);
  };
  return (
    <div className="space-y-3">
      <h3 className="text-white text-sm font-bold">Objects ({objects.length})</h3>
      {objects.length === 0 ? (
        <div className="text-gray-400 text-center py-8">
          <div className="text-4xl mb-2">📦</div>
          <p>No objects in scene</p>
        </div>
      ) : (
        <div className="space-y-1 max-h-96 overflow-y-auto">
          {objects.map((obj) => (
            <div
              key={obj.id}
              className={`flex items-center space-x-2 p-1 rounded text-xs cursor-pointer ${
                selectedIds.includes(obj.id) ? 'bg-orange-600' : 'bg-gray-700 hover:bg-gray-600'
              }`}
              onClick={() => selectObject(obj.id)}
            >
              <button
                className={`w-4 h-4 text-xs ${obj.visible ? 'text-green-400' : 'text-gray-500'}`}
                onClick={(e) => {
                  e.stopPropagation();
                  toggleVisibility(obj.id);
                }}
              >
                👁
              </button>
              <button
                className={`w-4 h-4 text-xs ${obj.locked ? 'text-red-400' : 'text-gray-500'}`}
                onClick={(e) => {
                  e.stopPropagation();
                  toggleLock(obj.id);
                }}
              >
                🔒
              </button>
              <span className="flex-1 truncate">{obj.name}</span>
              <button
                className="w-4 h-4 text-red-400 hover:text-red-300"
                onClick={(e) => {
                  e.stopPropagation();
                  deleteObject(obj.id);
                }}
              >
                ✕
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

===== src/components/ui/OrdinalsExporter.jsx =====
import { useState } from 'react';
import { useScene } from '../../state/sceneStore.jsx';
export function OrdinalsExporter() {
  const { objects, layers, groups } = useScene();
  const [isOpen, setIsOpen] = useState(false);
  const [exportSettings, setExportSettings] = useState({
    format: 'minified-jsx',
    optimization: 'aggressive',
    includeTextures: false,
    includeMaterials: true,
    precision: 2,
    compressionLevel: 'high',
    removeComments: true,
    inlineStyles: true,
    treeshake: true,
    target: 'inscription',
    maxSize: 400 // KB for Bitcoin inscription
  });
  const formats = [
    { value: 'minified-jsx', label: 'Minified JSX (Optimal)', size: 'Smallest' },
    { value: 'compact-json', label: 'Compact JSON', size: 'Small' },
    { value: 'threejs-optimized', label: 'Three.js Optimized', size: 'Medium' },
    { value: 'gltf-binary', label: 'glTF Binary', size: 'Large' },
    { value: 'custom-format', label: 'Custom Ordinals Format', size: 'Variable' }
  ];
  const optimizationLevels = [
    { value: 'none', label: 'No Optimization', description: 'Export as-is' },
    { value: 'basic', label: 'Basic', description: 'Remove unused data' },
    { value: 'moderate', label: 'Moderate', description: 'Compress geometries' },
    { value: 'aggressive', label: 'Aggressive', description: 'Maximum compression' }
  ];
  const calculateEstimatedSize = () => {
    let baseSize = objects.length * 50; // Base size per object in bytes
    // Add material overhead
    if (exportSettings.includeMaterials) {
      baseSize += objects.length * 30;
    }
    // Add texture overhead
    if (exportSettings.includeTextures) {
      baseSize += objects.length * 100; // Assuming texture references
    }
    // Apply optimization factors
    const optimizationFactors = {
      none: 1.0,
      basic: 0.8,
      moderate: 0.6,
      aggressive: 0.4
    };
    baseSize *= optimizationFactors[exportSettings.optimization];
    // Apply format factors
    const formatFactors = {
      'minified-jsx': 0.7,
      'compact-json': 0.8,
      'threejs-optimized': 0.9,
      'gltf-binary': 1.2,
      'custom-format': 0.5
    };
    baseSize *= formatFactors[exportSettings.format];
    return Math.round(baseSize / 1024 * 100) / 100; // Convert to KB
  };
  const generateOptimizedScene = () => {
    const scene = {
      metadata: {
        version: '1.0',
        generator: '3D Builder for Bitmap Nexus',
        timestamp: Date.now(),
        optimization: exportSettings.optimization
      }
    };
    // Filter and optimize objects
    const optimizedObjects = objects.map(obj => {
      const optimized = {
        id: obj.id,
        type: obj.type || obj.geometry,
        p: obj.position.map(p => parseFloat(p.toFixed(exportSettings.precision))), // position
        r: obj.rotation.map(r => parseFloat(r.toFixed(exportSettings.precision))), // rotation
        s: obj.scale.map(s => parseFloat(s.toFixed(exportSettings.precision)))      // scale
      };
      // Add geometry args with precision
      if (obj.geometryArgs) {
        optimized.g = obj.geometryArgs.map(arg =>
          typeof arg === 'number' ? parseFloat(arg.toFixed(exportSettings.precision)) : arg
        );
      }
      // Add materials if enabled
      if (exportSettings.includeMaterials && obj.material) {
        optimized.m = {
          c: obj.material.color,
          ...(obj.material.metalness !== undefined && { mt: obj.material.metalness }),
          ...(obj.material.roughness !== undefined && { r: obj.material.roughness }),
          ...(obj.material.opacity !== undefined && obj.material.opacity < 1 && { o: obj.material.opacity })
        };
      }
      // Add layer info
      if (obj.layerId && obj.layerId !== 'default') {
        optimized.l = obj.layerId;
      }
      return optimized;
    });
    scene.objects = optimizedObjects;
    // Add layers if they have custom properties
    const customLayers = layers.filter(layer =>
      layer.id !== 'default' || !layer.visible || layer.locked
    );
    if (customLayers.length > 0) {
      scene.layers = customLayers.map(layer => ({
        i: layer.id,
        n: layer.name,
        ...(layer.visible === false && { v: false }),
        ...(layer.locked === true && { l: true }),
        ...(layer.color !== '#3b82f6' && { c: layer.color })
      }));
    }
    return scene;
  };
  const generateJSXCode = (sceneData) => {
    const imports = [
      'import { Canvas } from "@react-three/fiber";',
      'import { CameraControls } from "@react-three/drei";'
    ].join('\n');
    const objectsJSX = sceneData.objects.map(obj => {
      const position = `[${obj.p.join(',')}]`;
      const rotation = `[${obj.r.join(',')}]`;
      const scale = `[${obj.s.join(',')}]`;
      const args = obj.g ? `args={[${obj.g.join(',')}]}` : '';
      const color = obj.m?.c ? `color="${obj.m.c}"` : '';
      return `    <mesh position={${position}} rotation={${rotation}} scale={${scale}}>
      <${obj.type}Geometry ${args} />
      <meshStandardMaterial ${color} />
    </mesh>`;
    }).join('\n');
    const jsx = `${imports}
export default function Scene() {
  return (
    <Canvas>
      <ambientLight intensity={0.5} />
      <pointLight position={[10,10,10]} />
      <CameraControls makeDefault />
      ${objectsJSX}
    </Canvas>
  );
}`;
    return exportSettings.format === 'minified-jsx' ? minifyJSX(jsx) : jsx;
  };
  const minifyJSX = (jsx) => {
    return jsx
      .replace(/\s+/g, ' ')
      .replace(/>\s+</g, '><')
      .replace(/\s*{\s*/g, '{')
      .replace(/\s*}\s*/g, '}')
      .replace(/\s*=\s*/g, '=')
      .trim();
  };
  const exportForOrdinals = () => {
    const sceneData = generateOptimizedScene();
    const estimatedSize = calculateEstimatedSize();
    let output;
    switch (exportSettings.format) {
      case 'minified-jsx':
        output = generateJSXCode(sceneData);
        break;
      case 'compact-json':
        output = JSON.stringify(sceneData);
        break;
      case 'custom-format':
        output = generateCustomFormat(sceneData);
        break;
      default:
        output = JSON.stringify(sceneData, null, 2);
    }
    // Create and download file
    const blob = new Blob([output], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ordinal-scene-${Date.now()}.${getFileExtension()}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log(`Exported scene: ${output.length} bytes (${(output.length/1024).toFixed(2)} KB)`);
  };
  const generateCustomFormat = (sceneData) => {
    // Ultra-compressed custom format for Bitcoin Ordinals
    const compressed = sceneData.objects.map(obj =>
      `${obj.type[0]}${obj.p.join(',')}|${obj.r.join(',')}|${obj.s.join(',')}`
    ).join(';');
    return compressed;
  };
  const getFileExtension = () => {
    switch (exportSettings.format) {
      case 'minified-jsx': return 'jsx';
      case 'compact-json': return 'json';
      case 'custom-format': return 'ord';
      default: return 'txt';
    }
  };
  const estimatedSize = calculateEstimatedSize();
  const sizeStatus = estimatedSize > exportSettings.maxSize ? 'error' :
                    estimatedSize > exportSettings.maxSize * 0.8 ? 'warning' : 'success';
  if (!isOpen) {
    return (
      <div className="absolute bottom-60 right-2 z-20">
        <button
          onClick={() => setIsOpen(true)}
          className="px-3 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 shadow-lg flex items-center gap-2"
        >
          ₿ Ordinals Export
          <span className={`text-xs px-2 py-1 rounded ${
            sizeStatus === 'success' ? 'bg-green-600' :
            sizeStatus === 'warning' ? 'bg-yellow-600' : 'bg-red-600'
          }`}>
            {estimatedSize} KB
          </span>
        </button>
      </div>
    );
  }
  return (
    <div className="absolute bottom-60 right-2 z-20 bg-gray-900 text-white p-4 rounded-lg shadow-xl w-80 max-h-96 overflow-y-auto">
      <div className="flex justify-between items-center mb-3">
        <h3 className="text-lg font-semibold">₿ Ordinals Export</h3>
        <button
          onClick={() => setIsOpen(false)}
          className="text-gray-400 hover:text-white"
        >
          ✕
        </button>
      </div>
      {/* Size Status */}
      <div className={`mb-4 p-3 rounded ${
        sizeStatus === 'success' ? 'bg-green-900' :
        sizeStatus === 'warning' ? 'bg-yellow-900' : 'bg-red-900'
      }`}>
        <div className="flex justify-between items-center">
          <span className="text-sm">Estimated Size:</span>
          <span className="font-bold">{estimatedSize} KB</span>
        </div>
        <div className="text-xs mt-1">
          Target: {exportSettings.maxSize} KB for inscription
        </div>
        {sizeStatus === 'error' && (
          <div className="text-xs mt-1 text-red-300">
            ⚠️ Too large for inscription! Increase optimization.
          </div>
        )}
      </div>
      {/* Export Format */}
      <div className="mb-3">
        <label className="text-xs block mb-1">Export Format</label>
        <select
          value={exportSettings.format}
          onChange={(e) => setExportSettings(prev => ({ ...prev, format: e.target.value }))}
          className="w-full bg-gray-800 text-white text-xs rounded p-2"
        >
          {formats.map(format => (
            <option key={format.value} value={format.value}>
              {format.label} ({format.size})
            </option>
          ))}
        </select>
      </div>
      {/* Optimization Level */}
      <div className="mb-3">
        <label className="text-xs block mb-1">Optimization</label>
        <select
          value={exportSettings.optimization}
          onChange={(e) => setExportSettings(prev => ({ ...prev, optimization: e.target.value }))}
          className="w-full bg-gray-800 text-white text-xs rounded p-2"
        >
          {optimizationLevels.map(level => (
            <option key={level.value} value={level.value}>
              {level.label} - {level.description}
            </option>
          ))}
        </select>
      </div>
      {/* Export Options */}
      <div className="space-y-2 mb-4">
        <div className="flex items-center justify-between">
          <label className="text-xs">Include Materials</label>
          <input
            type="checkbox"
            checked={exportSettings.includeMaterials}
            onChange={(e) => setExportSettings(prev => ({ ...prev, includeMaterials: e.target.checked }))}
          />
        </div>
        <div className="flex items-center justify-between">
          <label className="text-xs">Include Textures</label>
          <input
            type="checkbox"
            checked={exportSettings.includeTextures}
            onChange={(e) => setExportSettings(prev => ({ ...prev, includeTextures: e.target.checked }))}
          />
        </div>
        <div>
          <label className="text-xs block mb-1">Precision: {exportSettings.precision} decimals</label>
          <input
            type="range"
            min="0"
            max="4"
            value={exportSettings.precision}
            onChange={(e) => setExportSettings(prev => ({ ...prev, precision: parseInt(e.target.value) }))}
            className="w-full"
          />
        </div>
        <div>
          <label className="text-xs block mb-1">Max Size: {exportSettings.maxSize} KB</label>
          <input
            type="range"
            min="100"
            max="1000"
            step="50"
            value={exportSettings.maxSize}
            onChange={(e) => setExportSettings(prev => ({ ...prev, maxSize: parseInt(e.target.value) }))}
            className="w-full"
          />
        </div>
      </div>
      {/* Export Button */}
      <button
        onClick={exportForOrdinals}
        className="w-full px-4 py-2 bg-orange-600 hover:bg-orange-700 rounded text-sm font-semibold"
      >
        🚀 Export for Bitcoin Ordinals
      </button>
      <div className="mt-3 text-xs text-gray-400">
        💡 Optimized for Bitcoin inscription size limits
      </div>
    </div>
  );
}

===== src/components/ui/PerformancePanel.jsx =====
import { useState } from 'react';
import { useScene } from '../../state/sceneStore.jsx';
export function PerformancePanel() {
  const { objects, groups = [], layers } = useScene();
  const [isOpen, setIsOpen] = useState(false);
  const [performanceSettings, setPerformanceSettings] = useState({
    enableFrustumCulling: true,
    enableInstancedRendering: false,
    maxRenderDistance: 100,
    lodEnabled: true,
    shadowsEnabled: true,
    antialiasingEnabled: true,
    pixelRatio: window.devicePixelRatio
  });
  const stats = {
    totalObjects: objects.length,
    visibleObjects: objects.filter(obj => {
      const layer = layers.find(l => l.id === obj.layerId);
      const layerVisible = layer ? layer.visible : true;
      if (obj.groupId) {
        const group = groups.find(g => g.id === obj.groupId);
        const groupVisible = group ? group.visible : true;
        return layerVisible && groupVisible;
      }
      return layerVisible;
    }).length,
    totalGroups: groups.length,
    totalLayers: layers.length,
    memoryUsage: Math.round((objects.length * 0.5 + groups.length * 0.1) * 100) / 100 // Estimated MB
  };
  const updateSetting = (key, value) => {
    setPerformanceSettings(prev => ({ ...prev, [key]: value }));
  };
  const getPerformanceLevel = () => {
    if (stats.totalObjects < 10) return { level: 'Excellent', color: 'text-green-400' };
    if (stats.totalObjects < 50) return { level: 'Good', color: 'text-yellow-400' };
    if (stats.totalObjects < 100) return { level: 'Moderate', color: 'text-orange-400' };
    return { level: 'Heavy', color: 'text-red-400' };
  };
  const performance = getPerformanceLevel();
  if (!isOpen) {
    return (
      <div className="absolute bottom-20 right-2 z-20">
        <button
          onClick={() => setIsOpen(true)}
          className={`px-3 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 shadow-lg flex items-center gap-2`}
        >
          ⚡ Performance
          <span className={`text-xs ${performance.color}`}>
            ({performance.level})
          </span>
        </button>
      </div>
    );
  }
  return (
    <div className="absolute bottom-20 right-2 z-20 bg-gray-900 text-white p-4 rounded-lg shadow-xl w-80 max-h-96 overflow-y-auto">
      <div className="flex justify-between items-center mb-3">
        <h3 className="text-lg font-semibold">Performance Monitor</h3>
        <button
          onClick={() => setIsOpen(false)}
          className="text-gray-400 hover:text-white"
        >
          ✕
        </button>
      </div>
      {/* Scene Statistics */}
      <div className="mb-4 p-3 bg-gray-800 rounded">
        <h4 className="text-sm font-semibold mb-2">Scene Statistics</h4>
        <div className="grid grid-cols-2 gap-2 text-xs">
          <div>Total Objects: <span className="text-blue-400">{stats.totalObjects}</span></div>
          <div>Visible Objects: <span className="text-green-400">{stats.visibleObjects}</span></div>
          <div>Groups: <span className="text-yellow-400">{stats.totalGroups}</span></div>
          <div>Layers: <span className="text-purple-400">{stats.totalLayers}</span></div>
          <div className="col-span-2">
            Performance: <span className={performance.color}>{performance.level}</span>
          </div>
          <div className="col-span-2">
            Est. Memory: <span className="text-orange-400">{stats.memoryUsage} MB</span>
          </div>
        </div>
      </div>
      {/* Performance Settings */}
      <div className="space-y-3">
        <h4 className="text-sm font-semibold">Optimization Settings</h4>
        <div className="flex items-center justify-between">
          <label className="text-xs">Frustum Culling</label>
          <input
            type="checkbox"
            checked={performanceSettings.enableFrustumCulling}
            onChange={(e) => updateSetting('enableFrustumCulling', e.target.checked)}
            className="rounded"
          />
        </div>
        <div className="flex items-center justify-between">
          <label className="text-xs">Instanced Rendering</label>
          <input
            type="checkbox"
            checked={performanceSettings.enableInstancedRendering}
            onChange={(e) => updateSetting('enableInstancedRendering', e.target.checked)}
            className="rounded"
          />
        </div>
        <div className="flex items-center justify-between">
          <label className="text-xs">Level of Detail (LOD)</label>
          <input
            type="checkbox"
            checked={performanceSettings.lodEnabled}
            onChange={(e) => updateSetting('lodEnabled', e.target.checked)}
            className="rounded"
          />
        </div>
        <div className="flex items-center justify-between">
          <label className="text-xs">Shadows</label>
          <input
            type="checkbox"
            checked={performanceSettings.shadowsEnabled}
            onChange={(e) => updateSetting('shadowsEnabled', e.target.checked)}
            className="rounded"
          />
        </div>
        <div className="flex items-center justify-between">
          <label className="text-xs">Anti-aliasing</label>
          <input
            type="checkbox"
            checked={performanceSettings.antialiasingEnabled}
            onChange={(e) => updateSetting('antialiasingEnabled', e.target.checked)}
            className="rounded"
          />
        </div>
        <div>
          <label className="text-xs block mb-1">Max Render Distance</label>
          <input
            type="range"
            min="10"
            max="500"
            value={performanceSettings.maxRenderDistance}
            onChange={(e) => updateSetting('maxRenderDistance', parseInt(e.target.value))}
            className="w-full"
          />
          <div className="text-xs text-gray-400">{performanceSettings.maxRenderDistance} units</div>
        </div>
        <div>
          <label className="text-xs block mb-1">Pixel Ratio</label>
          <select
            value={performanceSettings.pixelRatio}
            onChange={(e) => updateSetting('pixelRatio', parseFloat(e.target.value))}
            className="w-full bg-gray-800 text-white text-xs rounded p-1"
          >
            <option value={0.5}>0.5x (Performance)</option>
            <option value={1.0}>1.0x (Balanced)</option>
            <option value={1.5}>1.5x (Quality)</option>
            <option value={2.0}>2.0x (High Quality)</option>
          </select>
        </div>
      </div>
      {/* Performance Tips */}
      <div className="mt-4 p-2 bg-blue-900 bg-opacity-30 rounded text-xs">
        <div className="font-semibold mb-1">💡 Performance Tips:</div>
        <ul className="space-y-1 text-gray-300">
          <li>• Use groups to organize similar objects</li>
          <li>• Hide unused layers to reduce render load</li>
          <li>• Enable frustum culling for large scenes</li>
          <li>• Lower pixel ratio on slower devices</li>
          {stats.totalObjects > 50 && (
            <li className="text-orange-400">⚠️ Consider using LOD for {stats.totalObjects}+ objects</li>
          )}
        </ul>
      </div>
    </div>
  );
}

===== src/components/ui/SettingsPanel.jsx =====
import { useScene } from '../../state/sceneStore.jsx';
export const SettingsPanel = () => {
  const { snapToGrid, gridSize, showGrid, setSceneState } = useScene();
  const updateSetting = (key, value) => {
    setSceneState({ [key]: value });
  };
  return (
    <div className="space-y-4">
      <h3 className="text-white text-sm font-bold">Settings</h3>
      {/* Grid Settings */}
      <div className="mb-4">
        <h4 className="text-xs text-gray-400 mb-2">Grid & Snap</h4>
        <div className="flex items-center justify-between mb-2">
          <label className="text-xs">Show Grid</label>
          <input
            type="checkbox"
            checked={showGrid}
            onChange={(e) => updateSetting('showGrid', e.target.checked)}
            className="w-4 h-4"
          />
        </div>
        <div className="flex items-center justify-between mb-2">
          <label className="text-xs">Snap to Grid</label>
          <input
            type="checkbox"
            checked={snapToGrid}
            onChange={(e) => updateSetting('snapToGrid', e.target.checked)}
            className="w-4 h-4"
          />
        </div>
        <div className="mb-2">
          <label className="block text-xs text-gray-400 mb-1">
            Grid Size: {gridSize}
          </label>
          <input
            type="range"
            min="0.1"
            max="2"
            step="0.1"
            value={gridSize}
            onChange={(e) => updateSetting('gridSize', parseFloat(e.target.value))}
            className="w-full"
          />
        </div>
      </div>
      {/* Performance Settings */}
      <div className="mb-4">
        <h4 className="text-xs text-gray-400 mb-2">Performance</h4>
        <div className="text-xs text-gray-300">
          <div>Objects: {useScene().objects.length}</div>
          <div>Selected: {useScene().selectedIds.length}</div>
        </div>
      </div>
      {/* Keyboard Shortcuts */}
      <div className="mb-4">
        <h4 className="text-xs text-gray-400 mb-2">Shortcuts</h4>
        <div className="text-xs text-gray-300 space-y-1">
          <div><kbd className="bg-gray-700 px-1 rounded">G</kbd> - Translate</div>
          <div><kbd className="bg-gray-700 px-1 rounded">R</kbd> - Rotate</div>
          <div><kbd className="bg-gray-700 px-1 rounded">S</kbd> - Scale</div>
          <div><kbd className="bg-gray-700 px-1 rounded">Esc</kbd> - Deselect</div>
          <div><kbd className="bg-gray-700 px-1 rounded">Del</kbd> - Delete</div>
        </div>
      </div>
    </div>
  );
};

===== src/components/ui/SimpleTransformControls.jsx =====
import React, { useRef, useState, useCallback } from 'react';
import { useThree, useFrame } from '@react-three/fiber';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import * as THREE from 'three';
export const SimpleTransformControls = ({ selectedMesh, onDraggingChanged }) => {
  const { transformMode, selectedObjectId } = useScene();
  const { updateObject } = useSceneActions();
  const { camera, gl, raycaster, pointer } = useThree();
  const [isDragging, setIsDragging] = useState(false);
  const [dragStartPosition, setDragStartPosition] = useState(null);
  const [dragStartMouse, setDragStartMouse] = useState(null);
  const handlePointerDown = useCallback((event) => {
    if (!selectedMesh) return;
    event.stopPropagation();
    setIsDragging(true);
    setDragStartPosition(selectedMesh.position.clone());
    setDragStartMouse({ x: pointer.x, y: pointer.y });
    if (onDraggingChanged) {
      onDraggingChanged(true);
    }
    // Disable orbit controls
    gl.domElement.style.cursor = 'grabbing';
  }, [selectedMesh, pointer, onDraggingChanged, gl]);
  const handlePointerMove = useCallback((event) => {
    if (!isDragging || !selectedMesh || !dragStartPosition || !dragStartMouse) return;
    const deltaX = pointer.x - dragStartMouse.x;
    const deltaY = pointer.y - dragStartMouse.y;
    // Simple translation based on mouse movement
    const newPosition = dragStartPosition.clone();
    newPosition.x += deltaX * 5; // Scale factor for mouse sensitivity
    newPosition.y -= deltaY * 5; // Invert Y axis
    selectedMesh.position.copy(newPosition);
    // Update the store immediately
    updateObject(selectedObjectId, {
      position: [newPosition.x, newPosition.y, newPosition.z]
    });
  }, [isDragging, selectedMesh, dragStartPosition, dragStartMouse, pointer, updateObject, selectedObjectId]);
  const handlePointerUp = useCallback(() => {
    setIsDragging(false);
    setDragStartPosition(null);
    setDragStartMouse(null);
    if (onDraggingChanged) {
      onDraggingChanged(false);
    }
    gl.domElement.style.cursor = 'default';
  }, [onDraggingChanged, gl]);
  // Set up event listeners
  React.useEffect(() => {
    if (!selectedMesh) return;
    const canvas = gl.domElement;
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointermove', handlePointerMove);
    canvas.addEventListener('pointerup', handlePointerUp);
    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown);
      canvas.removeEventListener('pointermove', handlePointerMove);
      canvas.removeEventListener('pointerup', handlePointerUp);
    };
  }, [selectedMesh, handlePointerDown, handlePointerMove, handlePointerUp, gl]);
  if (!selectedMesh || !selectedObjectId) {
    return null;
  }
  // Simple visual gizmo - just a wireframe box around the selected object
  return (
    <group>
      <mesh position={selectedMesh.position} scale={selectedMesh.scale} rotation={selectedMesh.rotation}>
        <boxGeometry args={[1.1, 1.1, 1.1]} />
        <meshBasicMaterial color="orange" wireframe transparent opacity={0.5} />
      </mesh>
    </group>
  );
};

===== src/components/ui/TextureManager.jsx =====
import { useState, useRef } from 'react';
import { useScene, useSceneActions } from '../../state/sceneStore.jsx';
import { useLoader } from '@react-three/fiber';
import { TextureLoader } from 'three';
export function TextureManager() {
  const { selectedObjectId, objects } = useScene();
  const { updateObject } = useSceneActions();
  const [isOpen, setIsOpen] = useState(false);
  const [textureUrls, setTextureUrls] = useState({
    diffuse: '',
    normal: '',
    roughness: '',
    metalness: '',
    displacement: '',
    emissive: ''
  });
  const fileInputRef = useRef();
  const selectedObject = objects.find(obj => obj.id === selectedObjectId);
  const predefinedTextures = [
    { name: 'Brick Wall', diffuse: 'https://threejs.org/examples/textures/brick_diffuse.jpg' },
    { name: 'Wood Floor', diffuse: 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg' },
    { name: 'Metal', diffuse: 'https://threejs.org/examples/textures/metal_diffuse.jpg' },
    { name: 'Concrete', diffuse: 'https://threejs.org/examples/textures/concrete_diffuse.jpg' },
    { name: 'Marble', diffuse: 'https://threejs.org/examples/textures/marble_diffuse.jpg' }
  ];
  const uvMappingTypes = [
    { name: 'Default', value: 'default' },
    { name: 'Planar X', value: 'planar-x' },
    { name: 'Planar Y', value: 'planar-y' },
    { name: 'Planar Z', value: 'planar-z' },
    { name: 'Cylindrical', value: 'cylindrical' },
    { name: 'Spherical', value: 'spherical' }
  ];
  const handleFileUpload = (event, textureType) => {
    const file = event.target.files[0];
    if (file) {
      const url = URL.createObjectURL(file);
      setTextureUrls(prev => ({ ...prev, [textureType]: url }));
      applyTexture(textureType, url);
    }
  };
  const applyTexture = (textureType, url) => {
    if (!selectedObjectId || !url) return;
    const textureUpdates = {
      material: {
        ...selectedObject.material,
        textures: {
          ...selectedObject.material?.textures,
          [textureType]: url
        }
      }
    };
    updateObject(selectedObjectId, textureUpdates);
  };
  const applyPredefinedTexture = (texture) => {
    if (!selectedObjectId) return;
    const textureUpdates = {
      material: {
        ...selectedObject.material,
        textures: {
          ...selectedObject.material?.textures,
          diffuse: texture.diffuse
        }
      }
    };
    updateObject(selectedObjectId, textureUpdates);
    setTextureUrls(prev => ({ ...prev, diffuse: texture.diffuse }));
  };
  const updateTextureSettings = (setting, value) => {
    if (!selectedObjectId) return;
    const textureUpdates = {
      material: {
        ...selectedObject.material,
        textureSettings: {
          ...selectedObject.material?.textureSettings,
          [setting]: value
        }
      }
    };
    updateObject(selectedObjectId, textureUpdates);
  };
  const clearTexture = (textureType) => {
    if (!selectedObjectId) return;
    const textures = { ...selectedObject.material?.textures };
    delete textures[textureType];
    const textureUpdates = {
      material: {
        ...selectedObject.material,
        textures
      }
    };
    updateObject(selectedObjectId, textureUpdates);
    setTextureUrls(prev => ({ ...prev, [textureType]: '' }));
  };
  if (!selectedObjectId) {
    return (
      <div className="absolute top-80 right-2 z-20">
        <div className="px-3 py-2 bg-gray-700 text-gray-400 rounded-lg shadow-lg text-sm">
          🎨 Select an object to edit textures
        </div>
      </div>
    );
  }
  if (!isOpen) {
    return (
      <div className="absolute top-80 right-2 z-20">
        <button
          onClick={() => setIsOpen(true)}
          className="px-3 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 shadow-lg"
        >
          🎨 Textures
        </button>
      </div>
    );
  }
  const currentTextures = selectedObject.material?.textures || {};
  const currentSettings = selectedObject.material?.textureSettings || {};
  return (
    <div className="absolute top-80 right-2 z-20 bg-gray-900 text-white p-4 rounded-lg shadow-xl w-80 max-h-96 overflow-y-auto">
      <div className="flex justify-between items-center mb-3">
        <h3 className="text-lg font-semibold">Texture Manager</h3>
        <button
          onClick={() => setIsOpen(false)}
          className="text-gray-400 hover:text-white"
        >
          ✕
        </button>
      </div>
      {/* Predefined Textures */}
      <div className="mb-4">
        <h4 className="text-sm font-semibold mb-2">Quick Textures</h4>
        <div className="grid grid-cols-2 gap-2">
          {predefinedTextures.map(texture => (
            <button
              key={texture.name}
              onClick={() => applyPredefinedTexture(texture)}
              className="p-2 bg-gray-800 hover:bg-gray-700 rounded text-xs"
            >
              {texture.name}
            </button>
          ))}
        </div>
      </div>
      {/* Texture Upload */}
      <div className="mb-4">
        <h4 className="text-sm font-semibold mb-2">Upload Textures</h4>
        <div className="space-y-2">
          {['diffuse', 'normal', 'roughness', 'metalness', 'displacement', 'emissive'].map(type => (
            <div key={type} className="flex items-center gap-2">
              <label className="text-xs w-20 capitalize">{type}:</label>
              <input
                type="file"
                accept="image/*"
                onChange={(e) => handleFileUpload(e, type)}
                className="hidden"
                ref={type === 'diffuse' ? fileInputRef : null}
              />
              <button
                onClick={() => {
                  const input = document.createElement('input');
                  input.type = 'file';
                  input.accept = 'image/*';
                  input.onchange = (e) => handleFileUpload(e, type);
                  input.click();
                }}
                className="px-2 py-1 bg-blue-600 hover:bg-blue-700 rounded text-xs flex-1"
              >
                {currentTextures[type] ? '✓ Loaded' : 'Upload'}
              </button>
              {currentTextures[type] && (
                <button
                  onClick={() => clearTexture(type)}
                  className="px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-xs"
                >
                  ✕
                </button>
              )}
            </div>
          ))}
        </div>
      </div>
      {/* Texture Settings */}
      <div className="space-y-3">
        <h4 className="text-sm font-semibold">Texture Settings</h4>
        <div>
          <label className="text-xs block mb-1">UV Mapping</label>
          <select
            value={currentSettings.uvMapping || 'default'}
            onChange={(e) => updateTextureSettings('uvMapping', e.target.value)}
            className="w-full bg-gray-800 text-white text-xs rounded p-1"
          >
            {uvMappingTypes.map(type => (
              <option key={type.value} value={type.value}>{type.name}</option>
            ))}
          </select>
        </div>
        <div>
          <label className="text-xs block mb-1">Repeat U: {currentSettings.repeatU || 1}</label>
          <input
            type="range"
            min="0.1"
            max="10"
            step="0.1"
            value={currentSettings.repeatU || 1}
            onChange={(e) => updateTextureSettings('repeatU', parseFloat(e.target.value))}
            className="w-full"
          />
        </div>
        <div>
          <label className="text-xs block mb-1">Repeat V: {currentSettings.repeatV || 1}</label>
          <input
            type="range"
            min="0.1"
            max="10"
            step="0.1"
            value={currentSettings.repeatV || 1}
            onChange={(e) => updateTextureSettings('repeatV', parseFloat(e.target.value))}
            className="w-full"
          />
        </div>
        <div>
          <label className="text-xs block mb-1">Rotation: {Math.round((currentSettings.rotation || 0) * 180 / Math.PI)}°</label>
          <input
            type="range"
            min="0"
            max={Math.PI * 2}
            step="0.1"
            value={currentSettings.rotation || 0}
            onChange={(e) => updateTextureSettings('rotation', parseFloat(e.target.value))}
            className="w-full"
          />
        </div>
        <div>
          <label className="text-xs block mb-1">Offset U: {(currentSettings.offsetU || 0).toFixed(2)}</label>
          <input
            type="range"
            min="-1"
            max="1"
            step="0.01"
            value={currentSettings.offsetU || 0}
            onChange={(e) => updateTextureSettings('offsetU', parseFloat(e.target.value))}
            className="w-full"
          />
        </div>
        <div>
          <label className="text-xs block mb-1">Offset V: {(currentSettings.offsetV || 0).toFixed(2)}</label>
          <input
            type="range"
            min="-1"
            max="1"
            step="0.01"
            value={currentSettings.offsetV || 0}
            onChange={(e) => updateTextureSettings('offsetV', parseFloat(e.target.value))}
            className="w-full"
          />
        </div>
      </div>
      <div className="mt-4 text-xs text-gray-400">
        💡 Upload PBR texture maps for realistic materials
      </div>
    </div>
  );
}

===== src/components/ui/TransformGizmo.jsx =====
import React from 'react';
import { TransformControls } from '@react-three/drei';
const TransformGizmo = ({ selectedMesh }) => {
  if (!selectedMesh) {
    return null;
  }
  return (
    <TransformControls
      object={selectedMesh}
      mode="translate"
      showX={true}
      showY={true}
      showZ={true}
      space="world"
      size={0.8}
    />
  );
};
export { TransformGizmo };
export default TransformGizmo;

===== src/components/ui/TransformIndicator.jsx =====
// filepath: src/components/ui/TransformIndicator.jsx
import React, { useState, useEffect } from 'react';
import { useScene } from '../../state/sceneStore.jsx';
export const TransformIndicator = () => {
  const { transformMode, selectedIds } = useScene();
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  useEffect(() => {
    if (selectedIds.length > 0) {
      setIsVisible(true);
      // Automatically hide after 1.5 seconds
      const timer = setTimeout(() => {
        setIsVisible(false);
      }, 1500);
      return () => clearTimeout(timer);
    } else {
      setIsVisible(false);
    }
  }, [transformMode, selectedIds]);
  // Track mouse movement for positioning the indicator
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    window.addEventListener('mousemove', handleMouseMove);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);
  if (!isVisible) return null;
  const modeInfo = {
    translate: { color: 'bg-blue-500', icon: '↔', name: 'Move' },
    rotate: { color: 'bg-green-500', icon: '🔄', name: 'Rotate' },
    scale: { color: 'bg-purple-500', icon: '↗', name: 'Scale' },
  };
  const mode = modeInfo[transformMode] || modeInfo.translate;
  return (
    <div
      className="fixed z-50 pointer-events-none"
      style={{
        left: position.x + 20,
        top: position.y + 20,
      }}
    >
      <div className={`${mode.color} text-white text-sm py-1 px-3 rounded-full shadow-lg flex items-center opacity-80`}>
        <span className="mr-2">{mode.icon}</span>
        <span className="font-medium">{mode.name}</span>
      </div>
    </div>
  );
};

===== src/components/ui/TransformToolbar.jsx =====
import React from 'react';
import { useScene } from '../../state/sceneStore.jsx';
export const TransformToolbar = () => {
  const { selectedObjectId, transformMode = 'translate', setSceneState } = useScene();
  if (!selectedObjectId) {
    return null;
  }
  const setTransformMode = (mode) => {
    setSceneState({ transformMode: mode });
  };
  return (
    <div className="absolute top-16 left-2 z-10 bg-gray-800 bg-opacity-90 rounded-lg p-2">
      <div className="text-white text-sm font-medium mb-2">Transform</div>
      <div className="flex flex-col space-y-1">
        <button
          onClick={() => setTransformMode('translate')}
          className={`px-3 py-1 text-sm rounded transition-colors ${
            transformMode === 'translate'
              ? 'bg-blue-600 text-white'
              : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
          }`}
        >
          Move (G)
        </button>
        <button
          onClick={() => setTransformMode('rotate')}
          className={`px-3 py-1 text-sm rounded transition-colors ${
            transformMode === 'rotate'
              ? 'bg-blue-600 text-white'
              : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
          }`}
        >
          Rotate (R)
        </button>
        <button
          onClick={() => setTransformMode('scale')}
          className={`px-3 py-1 text-sm rounded transition-colors ${
            transformMode === 'scale'
              ? 'bg-blue-600 text-white'
              : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
          }`}
        >
          Scale (S)
        </button>
      </div>
    </div>
  );
};

===== src/components/ui/UndoRedoToolbar.jsx =====
import React from 'react';
import { useScene } from '../../state/sceneStore.jsx';
import { undoRedoManager } from '../../utils/undoRedo';
export const UndoRedoToolbar = () => {
  const scene = useScene();
  // Temporarily disable undo/redo during migration
  const undo = () => console.log('Undo temporarily disabled');
  const redo = () => console.log('Redo temporarily disabled');
  const canUndo = () => false;
  const canRedo = () => false;
  const undoAvailable = canUndo();
  const redoAvailable = canRedo();
  const undoInfo = undoRedoManager.getUndoInfo();
  const redoInfo = undoRedoManager.getRedoInfo();
  return (
    <div className="absolute top-2 left-1/2 transform -translate-x-1/2 z-10 flex space-x-1 bg-gray-800 bg-opacity-90 rounded p-1">
      <button
        className={`px-2 py-1 rounded text-xs ${
          undoAvailable
            ? 'bg-blue-600 text-white hover:bg-blue-700'
            : 'bg-gray-600 text-gray-400 cursor-not-allowed'
        }`}
        onClick={undo}
        disabled={!undoAvailable}
        title={undoAvailable ? `Undo: ${undoInfo?.description}` : 'Nothing to undo'}
      >
        ↶ Undo
      </button>
      <button
        className={`px-2 py-1 rounded text-xs ${
          redoAvailable
            ? 'bg-blue-600 text-white hover:bg-blue-700'
            : 'bg-gray-600 text-gray-400 cursor-not-allowed'
        }`}
        onClick={redo}
        disabled={!redoAvailable}
        title={redoAvailable ? `Redo: ${redoInfo?.description}` : 'Nothing to redo'}
      >
        ↷ Redo
      </button>
      {/* History info */}
      <div className="px-2 py-1 text-xs text-gray-300 bg-gray-700 rounded">
        History: {undoRedoManager.history.length}
      </div>
    </div>
  );
};

===== src/hooks/useKeyboardShortcuts.js =====
import { useEffect } from 'react';
import { useScene, useSceneActions } from '../state/sceneStore.jsx';
export const useKeyboardShortcuts = () => {
  const { selectedIds, viewMode, setSceneState } = useScene();
  const { deleteObject, clearSelection } = useSceneActions();
  useEffect(() => {
    const handleKeyDown = (event) => {
      // Only handle shortcuts in 3D mode and when not typing in inputs
      if (viewMode !== '3d' || event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        return;
      }
      console.log(`Key pressed: ${event.key}, transform mode activated`); // Debug logging
      switch (event.key.toLowerCase()) {
        case 'z':
          if (event.ctrlKey || event.metaKey) {
            event.preventDefault();
            if (event.shiftKey) {
              // redo(); // Ctrl+Shift+Z = Redo - temporarily disabled
              console.log('Redo - temporarily disabled during migration');
            } else {
              // undo(); // Ctrl+Z = Undo - temporarily disabled
              console.log('Undo - temporarily disabled during migration');
            }
          }
          break;
        case 'y':
          if (event.ctrlKey || event.metaKey) {
            event.preventDefault();
            // redo(); // Ctrl+Y = Redo (alternative) - temporarily disabled
            console.log('Redo - temporarily disabled during migration');
          }
          break;
        case 'delete':
        case 'backspace':
          event.preventDefault();
          selectedIds.forEach(id => deleteObject(id));
          break;
        case 'escape':
          // Only clear selection if we're not actively transforming
          if (!event.shiftKey && !event.ctrlKey && !event.metaKey) {
            event.preventDefault();
            // Don't clear selection if a transform mode is active and objects are selected
            // This prevents accidental clearing during transform operations
            setSceneState(prev => {
              if (prev.selectedIds.length > 0 && prev.transformMode) {
                // Just disable transform mode instead of clearing selection
                return { transformMode: 'translate' };
              } else {
                // Clear selection only if no active transform
                clearSelection();
                return {};
              }
            });
          }
          break;
        case 'g':
          if (!event.ctrlKey && !event.metaKey) {
            event.preventDefault();
            setSceneState({ transformMode: 'translate' });
          }
          break;
        case 'r':
          if (!event.ctrlKey && !event.metaKey) {
            event.preventDefault();
            setSceneState({ transformMode: 'rotate' });
          }
          break;
        case 's':
          if (!event.ctrlKey && !event.metaKey) {
            event.preventDefault();
            setSceneState({ transformMode: 'scale' });
          }
          break;
        case 'h':
          event.preventDefault();
          // Toggle grid visibility
          setSceneState(prev => ({ showGrid: !prev.showGrid }));
          break;
        case 'tab':
          event.preventDefault();
          // Toggle snap to grid
          setSceneState(prev => ({ snapToGrid: !prev.snapToGrid }));
          break;
        case '1':
          event.preventDefault();
          setSceneState({ viewMode: '3d' });
          break;
        case '2':
          event.preventDefault();
          setSceneState({ viewMode: '2d' });
          break;
        default:
          break;
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedIds, viewMode]);
};

===== src/index.css =====
/* Gotham Regular */
@font-face {
  font-family: 'Gotham';
  src: url(/content/3e70186d09a3188e0d33758b4cd9773d401e4e6415be4a61146158c29363f450i1);
  font-weight: normal;
  font-style: normal;
}
/* Gotham Bold */
@font-face {
  font-family: 'Gotham';
  src: url(/content/0fba757d15ee4a8af1a7460f2e0306795d7da86b4170203619929e02974b1a41i0);
  font-weight: bold;
  font-style: normal;
}
/* Gotham Italic */
@font-face {
  font-family: 'Gotham';
  src: url(/content/3e70186d09a3188e0d33758b4cd9773d401e4e6415be4a61146158c29363f450i0);
  font-weight: normal;
  font-style: italic;
}
/* Gotham Italic Bold */
@font-face {
  font-family: 'Gotham';
  src: url(/content/3e70186d09a3188e0d33758b4cd9773d401e4e6415be4a61146158c29363f450i2);
  font-weight: bold;
  font-style: italic;
}
html, body, #root {
  margin: 0;
  width: 100%;
  height: 100%;
  background: #333;
  font-family: 'Gotham', serif;
}
.gloww {
  text-shadow: 0 0 55px #ff9900, 0 0 32px rgba(255, 119, 0, 0.7), 0 0 7px #000, 0 0 16px #000, 0 0 3px #bf00ff;
}

===== src/main.jsx =====
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import { SceneProvider } from './state/sceneStore.jsx'
import './index.css'
ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <SceneProvider>
      <App />
    </SceneProvider>
  </React.StrictMode>,
)

===== src/state/sceneStore.jsx =====
import { createContext, useContext, useState, useCallback } from 'react';
import { undoRedoManager } from '../utils/undoRedo.js';
// Create context for scene state
const SceneContext = createContext();
// Initial state
const initialState = {
  objects: [],
  selectedIds: [],
  selectedObjectId: null,
  viewMode: '3d',
  currentTool: 'Line',
  transformMode: 'translate',
  snapToGrid: true,
  gridSize: 0.5,
  showGrid: true,
  layers: [
    {
      id: 'default',
      name: 'Default Layer',
      visible: true,
      locked: false,
      color: '#3b82f6'
    }
  ],
  groups: [],
};
// Provider component
export const SceneProvider = ({ children }) => {
  const [state, setState] = useState(initialState);
  const setSceneState = useCallback((updates) => {
    if (typeof updates === 'function') {
      setState(prevState => ({ ...prevState, ...updates(prevState) }));
    } else {
      setState(prevState => ({ ...prevState, ...updates }));
    }
  }, []);
  const value = {
    ...state,
    setSceneState
  };
  return (
    <SceneContext.Provider value={value}>
      {children}
    </SceneContext.Provider>
  );
};
// Helper to save state for undo/redo
const saveStateForUndo = (description = 'Action') => {
  // This will need to be updated to work with the new context-based approach
  // For now, we'll skip undo functionality to get the app working
};
// Hook to read scene state
export const useScene = () => {
  const context = useContext(SceneContext);
  if (!context) {
    throw new Error('useScene must be used within a SceneProvider');
  }
  return context;
};
// Export setSceneState function for backwards compatibility
export const setSceneState = (updates) => {
  // This will be handled by the context provider
  console.warn('setSceneState called outside of component - use useScene hook instead');
};
// Initialize undo system with empty state
undoRedoManager.saveState(initialState, 'Initial State');
// These functions will now be used as helpers that can be called from components
// They need to be wrapped in custom hooks that have access to the context
// Convenience actions - these need to be converted to hooks
export const useSceneActions = () => {
  const { setSceneState } = useScene();
  const addObject = useCallback((obj) => {
    // Assign to default layer if no layer specified
    if (!obj.layerId) {
      obj.layerId = 'default';
    }
    saveStateForUndo(`Add ${obj.type || obj.geometry}`);
    setSceneState((prev) => ({ objects: [...prev.objects, obj] }));
  }, [setSceneState]);
  const selectObjects = useCallback((ids) => {
    setSceneState({
      selectedIds: ids,
      selectedObjectId: ids.length === 1 ? ids[0] : null
    });
  }, [setSceneState]);
  const toggleObjectSelection = useCallback((id) => {
    setSceneState((prev) => {
      const isSelected = prev.selectedIds.includes(id);
      const newSelectedIds = isSelected
        ? prev.selectedIds.filter(selectedId => selectedId !== id)
        : [...prev.selectedIds, id];
      return {
        selectedIds: newSelectedIds,
        selectedObjectId: newSelectedIds.length === 1 ? newSelectedIds[0] : null
      };
    });
  }, [setSceneState]);
  const clearSelection = useCallback(() => {
    setSceneState({ selectedIds: [], selectedObjectId: null });
  }, [setSceneState]);
  const updateObject = useCallback((id, updates) => {
    saveStateForUndo(`Update object`);
    setSceneState((prev) => ({
      objects: prev.objects.map(obj =>
        obj.id === id ? { ...obj, ...updates } : obj
      )
    }));
  }, [setSceneState]);
  const deleteObject = useCallback((id) => {
    saveStateForUndo(`Delete object`);
    setSceneState((prev) => ({
      objects: prev.objects.filter(obj => obj.id !== id),
      selectedIds: prev.selectedIds.filter(selectedId => selectedId !== id),
      selectedObjectId: prev.selectedObjectId === id ? null : prev.selectedObjectId
    }));
  }, [setSceneState]);
  return {
    addObject,
    selectObjects,
    toggleObjectSelection,
    clearSelection,
    updateObject,
    deleteObject
  };
};
// For backwards compatibility, export the old function names as well
export const selectObjects = (ids) => {
  console.warn('selectObjects called outside component - use useSceneActions hook instead');
};
export const toggleObjectSelection = (id) => {
  console.warn('toggleObjectSelection called outside component - use useSceneActions hook instead');
};
export const clearSelection = () => {
  console.warn('clearSelection called outside component - use useSceneActions hook instead');
};
export const updateObject = (id, updates) => {
  console.warn('updateObject called outside component - use useSceneActions hook instead');
};
export const deleteObject = (id) => {
  console.warn('deleteObject called outside component - use useSceneActions hook instead');
};
// Undo/Redo actions - temporarily disabled during migration
export const undo = () => {
  console.warn('undo temporarily disabled during state management migration');
};
export const redo = () => {
  console.warn('redo temporarily disabled during state management migration');
};
export const canUndo = () => false; // Temporarily return false
export const canRedo = () => false; // Temporarily return false
export const setViewMode = (mode) => {
  console.warn('setViewMode called outside component - use useScene hook instead');
};
// Layer management functions - temporarily disabled during migration
export const addLayer = (layer) => {
  console.warn('addLayer called outside component - use context hook instead');
};
export const deleteLayer = (layerId) => {
  console.warn('deleteLayer called outside component - use context hook instead');
};
export const updateLayer = (layerId, updates) => {
  console.warn('updateLayer called outside component - use context hook instead');
};
export const toggleLayerVisibility = (layerId) => {
  console.warn('toggleLayerVisibility called outside component - use context hook instead');
};
export const moveObjectToLayer = (objectId, layerId) => {
  console.warn('moveObjectToLayer called outside component - use context hook instead');
};
// Group management functions - temporarily disabled during migration
export const createGroup = (objectIds, groupName) => {
  console.warn('createGroup called outside component - use context hook instead');
};
export const ungroupObjects = (groupId) => {
  console.warn('ungroupObjects called outside component - use context hook instead');
};
export const addObjectToGroup = (objectId, groupId) => {
  console.warn('addObjectToGroup called outside component - use context hook instead');
};
export const removeObjectFromGroup = (objectId) => {
  console.warn('removeObjectFromGroup called outside component - use context hook instead');
};
export const toggleGroupVisibility = (groupId) => {
  console.warn('toggleGroupVisibility called outside component - use context hook instead');
};

===== src/utils/exportScene.js =====
// filepath: src/utils/exportScene.js
export const exportAsJSX = (objects) => {
  const meshes = objects
    .filter((obj) => obj.visible)
    .map((obj) => {
      const geometryTag = getGeometryTag(obj.geometry, obj.geometryArgs);
      const materialTag = getMaterialTag(obj.material);
      return `  <mesh position={[${obj.position.join(', ')}]} rotation={[${obj.rotation.join(', ')}]} scale={[${obj.scale.join(', ')}]}>
    ${geometryTag}
    ${materialTag}
  </mesh>`;
    })
    .join('\n');
  return `<>\n${meshes}\n</>`;
};
export const exportAsJSON = (objects) => {
  return JSON.stringify(
    objects
      .filter((obj) => obj.visible)
      .map((obj) => ({
        type: obj.type,
        geometry: obj.geometry,
        args: obj.geometryArgs,
        material: obj.material,
        position: obj.position,
        rotation: obj.rotation,
        scale: obj.scale,
      })),
    null,
    2
  );
};
const getGeometryTag = (geometry, args) => {
  const argsStr = args ? `args={[${args.join(', ')}]}` : '';
  return `<${geometry}Geometry ${argsStr} />`;
};
const getMaterialTag = (material) => {
  const props = Object.entries(material)
    .map(([key, value]) => {
      if (typeof value === 'string') {
        return `${key}="${value}"`;
      }
      return `${key}={${value}}`;
    })
    .join(' ');
  return `<mesh${material.type.charAt(0).toUpperCase() + material.type.slice(1)}Material ${props} />`;
};

===== src/utils/snapUtils.js =====
// Snap utilities for precise object placement
export const snapToGrid = (value, gridSize) => {
  return Math.round(value / gridSize) * gridSize;
};
export const snapPositionToGrid = (position, gridSize) => {
  return [
    snapToGrid(position[0], gridSize),
    snapToGrid(position[1], gridSize),
    snapToGrid(position[2], gridSize)
  ];
};
export const snapRotationTo45Degrees = (rotation) => {
  const degreesToRadians = Math.PI / 180;
  const snapAngle = 45 * degreesToRadians;
  return [
    Math.round(rotation[0] / snapAngle) * snapAngle,
    Math.round(rotation[1] / snapAngle) * snapAngle,
    Math.round(rotation[2] / snapAngle) * snapAngle
  ];
};
export const snapScaleToQuarters = (scale) => {
  const snapValue = 0.25;
  return [
    Math.max(snapValue, Math.round(scale[0] / snapValue) * snapValue),
    Math.max(snapValue, Math.round(scale[1] / snapValue) * snapValue),
    Math.max(snapValue, Math.round(scale[2] / snapValue) * snapValue)
  ];
};

===== src/utils/undoRedo.js =====
// Undo/Redo system for the 3D Builder App
class UndoRedoManager {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
    this.maxHistorySize = 50;
  }
  // Save current state to history
  saveState(state, actionDescription = 'Unknown Action') {
    // Remove any future states if we're not at the end
    if (this.currentIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.currentIndex + 1);
    }
    // Add new state
    this.history.push({
      state: JSON.parse(JSON.stringify(state)), // Deep clone
      description: actionDescription,
      timestamp: Date.now()
    });
    // Limit history size
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    } else {
      this.currentIndex++;
    }
  }
  // Get previous state
  undo() {
    if (this.canUndo()) {
      this.currentIndex--;
      return this.history[this.currentIndex];
    }
    return null;
  }
  // Get next state
  redo() {
    if (this.canRedo()) {
      this.currentIndex++;
      return this.history[this.currentIndex];
    }
    return null;
  }
  // Check if undo is possible
  canUndo() {
    return this.currentIndex > 0;
  }
  // Check if redo is possible
  canRedo() {
    return this.currentIndex < this.history.length - 1;
  }
  // Get current state info
  getCurrentInfo() {
    if (this.currentIndex >= 0 && this.currentIndex < this.history.length) {
      return this.history[this.currentIndex];
    }
    return null;
  }
  // Get undo info
  getUndoInfo() {
    if (this.canUndo()) {
      return this.history[this.currentIndex - 1];
    }
    return null;
  }
  // Get redo info
  getRedoInfo() {
    if (this.canRedo()) {
      return this.history[this.currentIndex + 1];
    }
    return null;
  }
  // Clear history
  clear() {
    this.history = [];
    this.currentIndex = -1;
  }
}
export const undoRedoManager = new UndoRedoManager();